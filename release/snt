#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /cmdline/
# Use snt as a standalone cmd line tool

set -u  # Will not allow for unset variables being used.

CLUSTERPATH="${CLUSTERPATH:-$PWD}"
PODPATH="${PODPATH:-$CLUSTERPATH/../pods}"
REMOTE_PACK_RELEASEDATA="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/pack_release_data/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_PACK_RELEASE_DATA()
{
    local _SPACE_NAME=\"_REMOTE_PACK_RELEASE_DATA\"

    _SYNC_REMOTE_PACK_RELEASE_DATA \"\$@\"
}

_SYNC_REMOTE_PACK_RELEASE_DATA()
{
    local _SPACE_NAME=\"_SYNC_REMOTE_PACK_RELEASE_DATA\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    # Indicate we are still busy
    touch \"\${HOSTHOME}/lock-token.txt\"

    local data=\"\"

    # Get the host list
    local hostFile=\"\${HOSTHOME}/cluster-hosts.txt\"
    local hosts=\"\"
    if [ -f \"\${hostFile}\" ]; then
        hosts=\"\$(cat \"\${hostFile}\")\"
        local newline=\"
\"
        STRING_SUBST \"hosts\" \"\${newline}\" \";\" 1
    fi
    data=\"\${data}\${data:+ }:hosts:\${hosts}\"

    local livePods=\"\${HOSTHOME}/pods\"

    if ! cd \"\${HOSTHOME}/pods\" 2>/dev/null; then
        printf \"%s\\n\" \"\${data}\"
        return 0
    fi
    local pod=
    for pod in \$(find . -mindepth 1 -maxdepth 1 -type d -not -path './.*'  |cut -b3-); do
        if [ ! -d \"\${pod}/release\" ]; then
            continue
        fi
        cd \"\${pod}/release\"

        local release=
        for release in \$(find . -mindepth 1 -maxdepth 1 -type d -not -path './.*'  |cut -b3-); do
            cd \"\${release}\"

            # Get the state of the pod
            local state=
            if ! state=\"\$(cat \"pod.state\" 2>/dev/null)\"; then  # There should only be one state file present.
                # No state file, this is treated as removed
                cd ..  # Step out of specific release
                continue
            fi
            data=\"\${data}\${data:+ }\${pod}:\${release}:\${state}\"

            # Check if this pod has configs
            if [ ! -d \"config\" ]; then
                cd ..  # Step out of specific release
                continue
            fi

            # Step into config dir and update the configs in the config dir
            cd \"config\"

            local dir=\"\${livePods}/\${pod}/release/\${release}/config\"
            local config=
            for config in \$(find . -mindepth 1 -maxdepth 1 -type d -not -path './.*' |cut -b3-); do
                # This could be a config directory.
                local chksumFile=\"\${dir}/\${config}.txt\"
                if [ -f \"\${chksumFile}\" ]; then
                    # This is the chksum file for the config, read it.
                    local chksum=\"\$(cat \"\${chksumFile}\")\"
                    # Sanatize it if it is corrupt, because a space here can ruin the whole thing.
                    STRING_SUBST \"chksum\" \" \" \"\" 1
                    data=\"\${data} \${pod}:\${release}:\${config}:\${chksum}\"
                fi
            done

            cd ..  # Step out of \"config\" dir
            cd ..  # Step out of release version dir
        done
        cd ../..  # Step out of \"pod/release\" dir
    done
    cd ../..  # Step out of \"pods\" dir

    printf \"%s\\n\" \"\${data}\"
}

STRING_SUBST()
{
    local _SPACE_NAME=\"STRING_SUBST\"

    local __varname=\"\${1}\"
    local __rstring=
    eval \"__rstring=\\\"\\\${\$1}\\\"\"
    shift

    local __subst=\"\${1}\"
    shift

    local __replace=\"\${1}\"
    shift

    local __global=\"\${1:-0}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __lstring=
    local __string=\"\"
    while true; do
        __lstring=\"\${__rstring%%\${__subst}*}\"
        if [ \"\${__lstring}\" = \"\${__rstring}\" ]; then
            __string=\"\${__string}\${__rstring}\"
            break
        fi
        __string=\"\${__string}\${__lstring}\${__replace}\"
        __rstring=\"\${__rstring#*\${__subst}}\"
        if [ \"\${__global}\" -ne 1 ]; then
            __string=\"\${__string}\${__rstring}\"
            break
        fi
    done
    eval \"\${__varname}=\\\"\\\${__string}\\\"\"
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_PACK_RELEASE_DATA \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/pack_release_data/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/pack_release_data/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_SET_COMMITCHAIN="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/set_commit_chain/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_SET_COMMITCHAIN()
{
    local _SPACE_NAME=\"_REMOTE_SET_COMMITCHAIN\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local chain=\"\${1}\"
    shift

    printf \"%s\\n\" \"\${chain}\" >\"\${HOSTHOME}/commit-chain.txt\"
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_SET_COMMITCHAIN \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/set_commit_chain/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/set_commit_chain/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_ACQUIRE_LOCK="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/acquire_lock/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_ACQUIRE_LOCK()
{
    local _SPACE_NAME=\"_REMOTE_ACQUIRE_LOCK\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local token=\"\${1}\"
    shift

    local seconds=\"\${1}\"
    shift

    if [ ! -d \"\${HOSTHOME}/pods\" ]; then
        PRINT \"Host is not initialized.\" \"error\" 0
        return 1
    fi

    local file=\"\${HOSTHOME}/lock-token.txt\"

    if [ -f \"\${file}\" ]; then
        local currentToken=\"\$(cat \"\${file}\")\"
        if [ \"\${currentToken}\" = \"\${token}\" ]; then
            # Pass through
            :
        else
            # Check timestamp
            local ts=\"\$(FILE_STAT \"\${file}\" \"%Y\")\"
            local now=\"\$(date +%s)\"
            local age=\"\$((now-ts))\"
            if [ \"\${age}\" -lt \"\${seconds}\" ]; then
                # Lock busy
                return 2
            fi
        fi
    fi

    printf \"%s\\n\" \"\${token}\" >\"\${file}\"
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

FILE_STAT()
{
    local _SPACE_NAME=\"FILE_STAT\"

    local file=\"\${1}\"
    shift

    local format=\"\${1}\"
    shift

    #
    # Check for BSD stat
    if command -v \"pkg\" >/dev/null || command -v \"brew\" >/dev/null ; then
        # Translate format options
        format=\$(printf \"%s\" \"\${format}\" | sed -e s'/%a/%A/g' -e s'/%n/%N/g' -e s'/%U/%Su/g' -e s'/%G/%Sg/g' -e s'/%Y/%m/g')
        stat -f \"\${format}\" \"\${file}\"
    else
        stat -c \"\${format}\" \"\${file}\"
    fi

    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Failed to stat file: \${file}.\" \"error\"
        return 1
    fi
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_ACQUIRE_LOCK \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/acquire_lock/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/acquire_lock/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_RELEASE_LOCK="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/release_lock/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_RELEASE_LOCK()
{
    local _SPACE_NAME=\"_REMOTE_RELEASE_LOCK\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local token=\"\${1}\"
    shift

    local file=\"\${HOSTHOME}/lock-token.txt\"

    if [ -f \"\${file}\" ]; then
        local currentToken=\"\$(cat \"\${file}\")\"
        if [ \"\${currentToken}\" = \"\${token}\" ]; then
            rm \"\${file}\"
        else
            PRINT \"Cannot release lock, because it does not belong to us.\" \"error\" 0
            return 2
        fi
    fi
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_RELEASE_LOCK \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/release_lock/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/release_lock/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_GET_HOSTMETADATA="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/get_host_metadata/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_GET_HOST_METADATA()
{
    local _SPACE_NAME=\"_REMOTE_GET_HOST_METADATA\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local clusterID=\"\$(cat \"\${HOSTHOME}/cluster-id.txt\" 2>/dev/null)\"
    local chain=\"\$(cat \"\${HOSTHOME}/commit-chain.txt\" 2>/dev/null)\"
    printf \"%s %s\\n\" \"\${clusterID}\" \"\${chain}\"
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_GET_HOST_METADATA \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/get_host_metadata/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/get_host_metadata/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_UPLOAD_ARCHIVE="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/upload_archive/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_UPLOAD_ARCHIVE()
{
    local _SPACE_NAME=\"_REMOTE_UPLOAD_ARCHIVE\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    # Indicate we are still busy
    touch \"\${HOSTHOME}/lock-token.txt\"

    local file=\"\$(_UTIL_GET_TMP_FILE)\"

    PRINT \"Receive archive on host to file \${file}\" \"debug\" 0

    # Tell the caller the path of tmpfile.
    printf \"%s\\n\" \"\${file}\"

    # Receive tar.gz content on stdin and store it to file.
    cat >\"\${file}\"
}

_UTIL_GET_TMP_FILE()
{
    local _SPACE_NAME=\"_UTIL_GET_TMP_FILE\"
    mktemp 2>/dev/null || mktemp -t 'sometmpdir'
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_UPLOAD_ARCHIVE \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/upload_archive/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/upload_archive/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_UNPACK_ARCHIVE="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/unpack_archive/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_UNPACK_ARCHIVE()
{
    local _SPACE_NAME=\"_REMOTE_UNPACK_ARCHIVE\"

    _SYNC_REMOTE_UNPACK_ARCHIVE \"\$@\"
}

_SYNC_REMOTE_UNPACK_ARCHIVE()
{
    local _SPACE_NAME=\"_SYNC_REMOTE_UNPACK_ARCHIVE\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local archive=\"\${1}\"
    shift

    local tmpDir=\"\$(_UTIL_GET_TMP_DIR)\"

    # Indicate we are still busy
    touch \"\${HOSTHOME}/lock-token.txt\"

    PRINT \"Unpack archive on host to \${HOSTHOME}\" \"info\" 0

    if ! tar xzf \"\${archive}\" -C \"\${tmpDir}\"; then
        PRINT \"Could not unpack archive.\" \"error\" 0
        return 1
    fi
    rm \"\${archive}\"

    if [ ! -d \"\${tmpDir}\" ]; then
        PRINT \"Could not unpack archive as expected.\" \"error\" 0
        return 1
    fi

    _SYNC_REMOTE_UNPACK_ARCHIVE2 \"\${HOSTHOME}\" \"\${tmpDir}\"
    rm -rf \"\${tmpDir}\"
}

_UTIL_GET_TMP_DIR()
{
    local _SPACE_NAME=\"_UTIL_GET_TMP_DIR\"
    mktemp -d 2>/dev/null || mktemp -d -t 'sometmpdir'
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

_SYNC_REMOTE_UNPACK_ARCHIVE2()
{
    local _SPACE_NAME=\"_SYNC_REMOTE_UNPACK_ARCHIVE2\"

    local HOSTHOME=\"\${1}\"
    shift

    local archiveDir=\"\${1}\"
    shift

    cd \"\${archiveDir}\"

    # Check the cluster-hosts.txt file
    if [ -f \"cluster-hosts.txt\" ]; then
        PRINT \"Update cluster-hosts.txt\" \"info\" 0
        mv -f \"cluster-hosts.txt\" \"\${HOSTHOME}\"
    fi

    if [ ! -d \"pods\" ]; then
        # No pods to update
        PRINT \"No pods to update, done unpacking updates.\" \"info\" 0
        return 0
    fi

    cd \"pods\"

    local livePods=\"\${HOSTHOME}/pods\"

    # Indicate we are still busy
    touch \"\${HOSTHOME}/lock-token.txt\"

    # Start moving files
    local pod=
    for pod in \$(find . -mindepth 1 -maxdepth 1 -type d -not -path './.*' |cut -b3-); do
        if [ ! -d \"\${pod}/release\" ]; then
            continue;
        fi
        cd \"\${pod}/release\"
        local release=
        for release in \$(find . -mindepth 1 -maxdepth 1 -type d -not -path './.*' |cut -b3-); do
            cd \"\${release}\"

            PRINT \"Update pod \${pod}:\${release}\" \"info\" 0

            # Move sh and state files inside release dir
            local dir=\"\${livePods}/\${pod}/release/\${release}\"
            mkdir -p \"\${dir}\"
            local file=
            for file in \$(find . -mindepth 1 -maxdepth 1 -type f -not -path './.*' |cut -b3-); do
                # This would be a pod, pod.state, ingress, etc file, just move it over to the live location.
                mv -f \"\${file}\" \"\${dir}\"
            done

            # Step inside config dir
            if [ ! -d \"config\" ]; then
                cd ..  # Step out of \"release\" dir.
                continue
            fi

            # Update the configs in the config dir
            cd \"config\"
            local config=
            for config in \$(find . -mindepth 1 -maxdepth 1 -type d -not -path './.*' |cut -b3-); do
                # This is a config directory.
                # First empty the current directory on the host,
                # then mv all files over from here.
                # After emptying the dir we then remove the chk sum file
                # which means that we won't empty the dir again on a resumed
                # unpacking.
                local dir=\"\${livePods}/\${pod}/release/\${release}/config\"
                local chksumFile=\"\${dir}/\${config}.txt\"
                # NOTE: we could make the resume more clever by deciding on this when starting. Samll risk now is that there's a timeout on update and another update comes in and \"resumes\" when it should reset.
                local isResumed=\"0\"
                if [ ! -f \"\${chksumFile}\" ]; then
                    # This means that this unpacking has been resumed and we
                    # should not delete the target files (again).
                    PRINT \"Resuming unpacking of pod config \${pod}:\${release}:\${config}\" \"info\" 0
                    isResumed=\"1\"
                else
                    PRINT \"Unpacking pod config \${pod}:\${release}:\${config}\" \"info\" 0
                fi
                if ! cd \"\${config}\"; then
                    return 1
                fi
                local dir=\"\${livePods}/\${pod}/release/\${release}/config/\${config}\"
                mkdir -p \"\${dir}\"
                if [ \"\${isResumed}\" = \"0\" ]; then
                    # Empty the live dir
                    ( cd \"\${dir}\" && ls -A |xargs rm -rf )
                    rm \"\${chksumFile}\"
                fi

                # mv new files over
                local file2=
                for file2 in \$(find . -mindepth 1 -maxdepth 1 -not -path './.*' |cut -b3-); do
                    mv -f \"\${file2}\" \"\${dir}\"
                done
                cd ..  # step out of config dir
            done

            # Move checksum files, important to do this after we have moved over config files.
            local dir=\"\${livePods}/\${pod}/release/\${release}/config\"
            local file2=
            for file2 in \$(find . -mindepth 1 -maxdepth 1 -type f -not -path './.*' |cut -b3-); do
                # This would be a chk sum file, move it over.
                mv -f \"\${file2}\" \"\${dir}\"
            done
            cd ..  # Step out of \"config\" dir
            cd .. # Step of out of release version dir
        done
        cd ..  # Step out of \"release\" dir.
    done
    cd ../.. # Step out of archiveDir

    PRINT \"Done unpacking updates.\" \"info\" 0
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_UNPACK_ARCHIVE \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/unpack_archive/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/unpack_archive/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_INIT_HOST="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/init_host/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_INIT_HOST()
{
    local _SPACE_NAME=\"_REMOTE_INIT_HOST\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local clusterID=\"\${1}\"
    shift

    local force=\"\${1}\"
    shift

    local file=\"\${HOSTHOME}/cluster-id.txt\"
    if [ -f \"\${file}\" ]; then
        local id=\"\$(cat \"\${file}\")\"
        if [ \"\${id}\" != \"\${clusterID}\" ] && [ \"\${force}\" != \"true\" ]; then
            return 2
        fi
    fi

    mkdir -p \"\${HOSTHOME}/pods\"

    printf \"%s\\n\" \"\${clusterID}\" >\"\${file}\"

    PRINT \"Host now belongs to \${clusterID}\" \"info\" 0
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_INIT_HOST \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/init_host/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/init_host/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_HOST_SETUP="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/setup_host/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 


{ RUN_SU=\$(cat) ; }<<\"0_SU_SPACEGAL_SAYS_END_OF_FINITY_\"
set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_HOST_SETUP()
{
    local _SPACE_NAME=\"_REMOTE_HOST_SETUP\"

    local hosthome=\"\${1}\"
    shift

    local user=\"\${1}\"
    shift

    local ports=\"\${1}\"
    shift

    local internals=\"\${1}\"
    shift

    if [ \$(id -u) != 0 ]; then
        PRINT \"This needs to be run as root.\" \"error\" 0
        return 1
    fi

    # Create regular user
    # pub key on stdin
    if ! _OS_CREATE_USER \"\${user}\"; then
        PRINT \"Could not create user \${user}\" \"error\" 0
        return 1
    fi

    # Install podman
    if ! OS_INSTALL_PKG \"podman\"; then
        PRINT \"Could not install podman\" \"error\" 0
    fi
    local podmanVersion=\"\$(podman --version)\"
    PRINT \"Installed \${podmanVersion}\" \"info\" 0

    # Check /etc/subgid /etc/subuid
    if ! grep -q \"^\${user}:\" \"/etc/subgid\"; then
        PRINT \"Adding user to /etc/subgid\" \"info\" 0
        printf \"%s:90000:9999\\n\" \"\${user}\" >>\"/etc/subgid\"
        podman system migrate
    fi

    if ! grep -q \"^\${user}:\" \"/etc/subuid\"; then
        PRINT \"Adding user to /etc/subuid\" \"info\" 0
        printf \"%s:90000:9999\\n\" \"\${user}\" >>\"/etc/subuid\"
        podman system migrate
    fi

    # Allow for users to bind from port 1 and updwards
    sysctl net.ipv4.ip_unprivileged_port_start=1

    # Configure firewalld
    # TODO: this is tailored for use with how Linode does it on CentOS atm.
    # We might want to add another \"internal\" zone, instead of adding the rich rule for internal networking onto the default zone.
    if ! command -v firewall-cmd >/dev/null 2>/dev/null; then
        PRINT \"firewall-cmd not existing, cannot configure firewall to expose/hide ports. You need to make sure that worker machines are not exposed to the internet, but only to the local network and that the loadbalancers are properly exposed. This problem can go away if you choose a CentOS image.\" \"security\" 0
        # Best way to catch users interest is to stall the terminal.
        sleep 3
    else
        local port=
        for port in \$(firewall-cmd --list-ports); do
            PRINT \"Remove port \${port}\" \"info\" 0
            firewall-cmd --permanent --remove-port \"\${port}\"
        done
        if [ -n \"\${ports}\" ]; then
            local port=
            for port in \${ports}; do
                PRINT \"Open port \${port}/tcp\" \"info\" 0
                firewall-cmd --permanent --add-port=\${port}/tcp
            done
        fi
        # Remove any preadded ssh service, we do everything using port numbers.
        if firewall-cmd --list-services |grep -q \"\<ssh\>\"; then
            PRINT \"Trim services of firewalld\" \"info\" 0
            firewall-cmd --permanent --remove-service ssh
        fi
        local rules=
        rules=\"\$(firewall-cmd --list-rich-rules)\"
        local _ifs=\"\$IFS\"
        IFS=\"
\"
        local rule=
        for rule in \${rules}; do
            PRINT \"Remove current rich rule: \${rule}\" \"info\" 0
            firewall-cmd --permanent --remove-rich-rule \"\${rule}\"
        done
        IFS=\"\${_ifs}\"

        # Add a rule to allow all traffic from internal IPs
        # Without this rule only the specific ports opened are available to the internal networking.
        local network=
        for network in \${internals}; do
            PRINT \"Add rich rule for: \${network}\" \"info\" 0
            if ! firewall-cmd --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"'\${network}'\" accept'; then
                PRINT \"Could not add internal networking, adding some for rescue mode\" \"error\" 0
                # TODO: not sure this is the correct way of setting the internal networks
                firewall-cmd --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.0.0/16\" accept'
                firewall-cmd --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"10.0.0.0/8\" accept'
                break
            fi
        done

        PRINT \"Reload firewall\" \"info\" 0
        firewall-cmd --reload
    fi

    return

    # TODO
    # Download the simplenetes daemon

    # Make sure the bin is managed by systemd.
    local file=\"/etc/systemd/system/simplenetes.service\"
    local unit=\"[Unit]
Description=Simplenetes Daemon managing pods and ramdisks
After=network-online.target

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/bin/simplenetesd
Restart=always

[Install]
WantedBy=multi-user.target\"

    printf \"%s\\n\" \"\${unit}\" >\"\${file}\"

    #systemctl daemon-reload
    systemctl enable simplenetes
    systemctl start simplenetes
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

OS_INSTALL_PKG()
{
    local _SPACE_NAME=\"OS_INSTALL_PKG\"

    local pkg=\"\${1}\"
    shift

    PRINT \"Install pkg(s) (untranslated): \${pkg}.\" \"debug\"

    local out_ostype=''
    local out_ospkgmgr=''
    local out_oshome=''
    local out_oscwd=''
    local out_osinit=''
    OS_ID

    _OS_PKG_TRANSLATE

    if [ \"\${pkg}\" = \"\" ]; then
        PRINT \"Package has no target for pkg mgr: \${out_ospkgmgr}.\"
        return 0
    fi

    PRINT \"Install package(s) using \${out_ospkgmgr}: \${pkg}.\" \"info\"

    if [ \"\${out_ospkgmgr}\" = \"apt\" ]; then
        apt-get -y install \${pkg}
        if [ \"\$?\" -eq 100 ]; then
            OS_UPDATE
            apt-get -y install \${pkg}
        fi
    elif [ \"\${out_ospkgmgr}\" = \"pacman\" ]; then
        pacman -Syu --noconfirm \${pkg}
        if [ \"\$?\" -gt 0 ]; then
            OS_UPDATE
            pacman -Syu --noconfirm \${pkg}
        fi
    elif [ \"\${out_ospkgmgr}\" = \"yum\" ]; then
        yum -y install \${pkg}
    elif [ \"\${out_ospkgmgr}\" = \"apk\" ]; then
        apk add \${pkg}
        if [ \"\$?\" -gt 0 ]; then
            OS_UPDATE
            apk add \${pkg}
        fi
    elif [ \"\${out_ospkgmgr}\" = \"brew\" ]; then
        brew install \${pkg}
        if [ \"\$?\" -gt 0 ]; then
            OS_UPDATE
            brew install \${pkg}
        fi
    elif [ \"\${out_ospkgmgr}\" = \"pkg\" ]; then
        pkg install \${pkg}
        if [ \"\$?\" -gt 0 ]; then
            OS_UPDATE
            pkg install \${pkg}
        fi
    else
        PRINT \"Could not determine what package manager is being used in the OS.\" \"error\"
        return 1
    fi

    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not install \${pkg}.\" \"error\"
        return 1
    fi

    PRINT \"Package(s): \${pkg}, installed successfully!\" \"ok\"
}

_OS_CREATE_USER()
{
    local _SPACE_NAME=\"_OS_CREATE_USER\"

    local targetuser=\"\${1}\"
    shift

    PRINT \"Create \${targetuser}.\" \"debug\"

    # shellcheck disable=2034
    local out_ostype=''
    local out_ospkgmgr=''
    local out_oshome=''
    local out_oscwd=''
    local out_osinit=''
    OS_ID

    # Read pub key from stdin
    local keycontents=\"\$(cat)\"

    local home=\"\${out_oshome}/\${targetuser}\"
    if ! OS_USER_EXIST \"\${targetuser}\"; then
        OS_ADD_USER \"\${targetuser}\" \"\${home}\"
    fi &&
    FILE_CHMOD \"700\" \"\${home}\" &&
    FILE_MKDIRP \"\${home}/.ssh\" &&
    FILE_CHMOD \"700\" \"\${home}/.ssh\" &&
    FILE_ROW_PERSIST \"\${keycontents}\" \"\${home}/.ssh/authorized_keys\" &&
    FILE_CHMOD \"600\" \"\${home}/.ssh/authorized_keys\" &&
    FILE_CHOWNR \"\${targetuser}:\${targetuser}\" \"\${home}/.ssh\"

    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not create user: \${targetuser}.\" \"error\"
        return 1
    fi
}

OS_ID()
{
    local _SPACE_NAME=\"OS_ID\"

    out_ostype=\"gnu\"
    out_oshome=\"/home\"
    out_oscwd=\"\$(pwd)\"
    out_ospkgmgr=
    out_osinit=\"sysvinit\"

    if OS_COMMAND \"systemctl\" >/dev/null; then
        out_osinit=\"systemd\"
    fi

    if [ \"\${out_oscwd}\" = \"/\" ]; then
        # We'll conform the root directory to not end with slash,
        # since other directories do not end with slash.
        out_oscwd=\"/.\"
    fi

    [ -f \"/etc/debian_version\" ] && out_ospkgmgr=\"apt\"
    [ -f \"/etc/arch-release\" ] && out_ospkgmgr=\"pacman\"
    [ -d \"/etc/yum\" ] && out_ospkgmgr=\"yum\"
    [ -f \"/etc/redhat-release\" ] && out_ospkgmgr=\"yum\"
    [ -f \"/etc/alpine-release\" ] && { out_ospkgmgr=\"apk\"; out_ostype=\"busybox\"; }

    # Some releases are more tricky.
    if [ \"\${out_ospkgmgr}\" = \"\" ]; then
        if OS_COMMAND \"apt-get\" >/dev/null; then
            out_ospkgmgr=\"apt\"
        elif OS_COMMAND \"pacman\" >/dev/null; then
            out_ospkgmgr=\"pacman\"
        elif OS_COMMAND \"yum\" >/dev/null; then
            out_ospkgmgr=\"yum\"
        elif OS_COMMAND \"apk\" >/dev/null; then
            out_ospkgmgr=\"apk\"
            # We assume Alpine Linux runs on BusyBox.
            # We could have a more fine grained check,
            # but we would have to execute 'ls' a couple of times to do that.
            out_ostype=\"busybox\"
        elif OS_COMMAND \"brew\" >/dev/null; then
            out_ospkgmgr=\"brew\"
            out_ostype=\"darwin\"
            out_oshome=\"/Users\"
            out_osinit=\"launchd\"
        elif OS_COMMAND \"pkg\" >/dev/null; then
            out_ospkgmgr=\"pkg\"
            out_ostype=\"FreeBSD\"
            out_osinit=\"rc\"
        fi
    fi

    return 0
}

_OS_PKG_TRANSLATE()
{
    local _SPACE_NAME=\"_OS_PKG_TRANSLATE\"
    local out_ostype=''
    local out_ospkgmgr=''
    local out_oshome=''
    local out_oscwd=''
    local out_osinit=''
    OS_ID

    local pkg2=\"\${pkg}\"
    local p=\"\"
    pkg=\"\"
    for p in \${pkg2}; do
        # This function should be further added to
        # to handle more packages.
        if [ \"\${out_ospkgmgr}\" = \"apk\" ]; then
            if [ \"\${p}\" = \"openssh-server\" ]; then
                p=\"openssh\"
            elif [ \"\${p}\" = \"openssh-client\" ]; then
                p=\"openssh\"
            elif [ \"\${p}\" = \"libyaml-dev\" ]; then
                p=\"yaml-dev\"
            elif [ \"\${p}\" = \"libreadline-dev\" ]; then
                p=\"readline-dev\"
            elif [ \"\${p}\" = \"libncurses-dev\" ]; then
                p=\"ncurses-dev\"
            fi
        elif [ \"\${out_ospkgmgr}\" = \"yum\" ]; then
            if [ \"\${p}\" = \"coreutils\" ]; then
                p=\"xtra-utils\"
            #elif [ \"\${p}\" = \"lua5.1\" ]; then
                #p=\"lua\"
            elif [ \"\${p}\" = \"openssh-client\" ]; then
                p=\"openssh-clients\"
            elif [ \"\${p}\" = \"libyaml-dev\" ]; then
                p=\"libyaml-devel\"
            elif [ \"\${p}\" = \"libc-dev\" ]; then
                p=\"glibc-devel glibc-headers\"
            #elif [ \"\${p}\" = \"lua5.1-dev\" ]; then
                #p=\"lua-devel\"
            elif [ \"\${p}\" = \"libreadline-dev\" ]; then
                p=\"readline-devel\"
            elif [ \"\${p}\" = \"libncurses-dev\" ]; then
                p=\"ncurses-devel\"
            fi
        elif [ \"\${out_ospkgmgr}\" = \"pacman\" ]; then
            if [ \"\${p}\" = \"lua5.1\" ]; then
                p=\"lua51\"
            elif [ \"\${p}\" = \"lua5.2\" ]; then
                p=\"lua52\"
            elif [ \"\${p}\" = \"lua5.3\" ]; then
                p=\"lua\"  # NOTE: This is dependant on pacman version since one day \"lua\" will mean \"lua5.4\", which is not good.
            elif [ \"\${p}\" = \"openssh-server\" ]; then
                p=\"openssh\"
            elif [ \"\${p}\" = \"openssh-client\" ]; then
                p=\"openssh\"
            elif [ \"\${p}\" = \"libyaml-dev\" ]; then
                p=\"libyaml\"
            elif [ \"\${p}\" = \"libc-dev\" ]; then
                p=\"linux-api-headers\"
            elif [ \"\${p}\" = \"lua5.1-dev\" ]; then
                p=\"lua51\"
            elif [ \"\${p}\" = \"libreadline-dev\" ]; then
                p=\"readline\"
            elif [ \"\${p}\" = \"libncurses-dev\" ]; then
                p=\"ncurses\"
            fi
        fi
        if [ -z \"\${p}\" ]; then
            continue
        fi
        pkg=\"\${pkg:+\$pkg }\${p}\"
    done
}

OS_UPDATE()
{
    local _SPACE_NAME=\"OS_UPDATE\"

    local out_ostype=''
    local out_ospkgmgr=''
    local out_oshome=''
    local out_oscwd=''
    local out_osinit=''
    OS_ID

    PRINT \"Update package lists.\" \"info\"

    if [ \"\${out_ospkgmgr}\" = \"apt\" ]; then
        apt-get update -y
    elif [ \"\${out_ospkgmgr}\" = \"pacman\" ]; then
        pacman --noconfirm -Sy
    elif [ \"\${out_ospkgmgr}\" = \"yum\" ]; then
        :
    elif [ \"\${out_ospkgmgr}\" = \"apk\" ]; then
        apk update
    elif [ \"\${out_ospkgmgr}\" = \"brew\" ]; then
        brew update
    elif [ \"\${out_ospkgmgr}\" = \"pkg\" ]; then
        pkg update
    else
        PRINT \"Could not determine what package manager is being used in the OS.\" \"error\"
        return 1
    fi

    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not update package lists.\" \"error\"
        return 1
    fi
}

FILE_CHMOD()
{
    local _SPACE_NAME=\"FILE_CHMOD\"

    local octets=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"chmod \${file} to \${octets}.\" \"debug\"

    chmod \"\${octets}\" \"\${file}\"
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not chmod \${file} to \${octets}.\" \"error\"
        return 1
    fi
}

FILE_MKDIRP()
{
    local _SPACE_NAME=\"FILE_MKDIRP\"

    local dir=\"\$*\"

    PRINT \"Creating directories: \${dir}.\" \"debug\"
    mkdir -p \${dir}
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not create directory: \${dir}.\" \"error\"
        return 1
    fi
}

FILE_ROW_PERSIST()
{
    local _SPACE_NAME=\"FILE_ROW_PERSIST\"

    local row=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"Make sure that row exist in \${file}: \${row}\" \"debug\"

    grep -q \"^\${row}\\\$\" \"\${file}\" 2>/dev/null
    local status=\"\$?\"
    if [ \"\${status}\" = \"2\" ]; then
        PRINT \"File not found: \${file}, create it and add row.\" \"debug\"
        FILE_APPEND_ROW \"\${row}\" \"\${file}\"
    elif [ \"\${status}\" = \"1\" ]; then
        PRINT \"Row does not exist, add row.\" \"debug\"
        FILE_APPEND_ROW \"\${row}\" \"\${file}\"
    fi
}

FILE_CHOWNR()
{
    local _SPACE_NAME=\"FILE_CHOWNR\"

    local owner=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"chown \${file} to \${owner}.\" \"debug\"

    chown -R \"\${owner}\" \"\${file}\"
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not chown -R \${file} to \${owner}.\" \"error\"
        return 1
    fi
}

OS_ADD_USER()
{
    local _SPACE_NAME=\"OS_ADD_USER\"

    local targetuser=\"\${1}\"
    shift

    local home=\"\${1}\"
    shift

    local shpath=\"\${1-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    if [ \"\${shpath}\" = \"\" ]; then
        shpath=\"\$(OS_COMMAND bash)\"
        if [ \"\$?\" -gt 0 ]; then
            shpath=\"\$(OS_COMMAND sh)\"
        fi
    fi

    if OS_COMMAND useradd >/dev/null; then
        useradd -m -d \"\${home}\" -s \"\${shpath}\" -U \"\${targetuser}\"
    elif OS_COMMAND adduser >/dev/null; then
        adduser -D -h \"\${home}\" -s \"\${shpath}\" \"\${targetuser}\"
    else
        PRINT \"No useradd/adduser installed.\" \"error\"
        return 1
    fi
}

OS_USER_EXIST()
{
    local _SPACE_NAME=\"OS_USER_EXIST\"

    # shellcheck disable=SC2039
    local targetuser=\"\${1}\"
    shift

    PRINT \"Check if user \${targetuser} exists.\" \"debug\"

    id -u \"\${targetuser}\" >/dev/null 2>&1
    if [ \"\$?\" -eq 0 ]; then
        PRINT \"User does exist.\" \"debug\"
        return 0
    else
        PRINT \"User does not exist.\" \"debug\"
        return 1
    fi
}

OS_COMMAND()
{
    local _SPACE_NAME=\"OS_COMMAND\"

    local cmd=\"\${1}\"
    shift

    command -v \${cmd} >/dev/null
}

FILE_APPEND_ROW()
{
    local _SPACE_NAME=\"FILE_APPEND_ROW\"

    local data=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"Append row to \${file}.\" \"debug\"

    # We want to make sure that the last byte before the append, if any,
    # is a newline character.
    local newline=\"\"
    if [ -f \"\${file}\" ]; then
        local cr=\"
\"
        local char=
        char=\"\$(tail -c -1 \${file})\"
        if [ \"\${char}\" != \"\" ] && [ \"\${char}\" != \"\${cr}\" ]; then
            newline=\"\${cr}\"
        fi
    fi

    printf \"%s\n\" \"\${newline}\${data}\" | tee -a \"\${file}\" >/dev/null
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not write to \${file}.\" \"error\"
        return 1
    fi
}

main()
{
    _REMOTE_HOST_SETUP \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/setup_host/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/setup_host/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\"
0_SU_SPACEGAL_SAYS_END_OF_FINITY_

shell=\"\"
if [ -n \"\${BASH_VERSION-}\" ]; then
    shell=\$(command -v bash 2>/dev/null)
fi
if [ -z \"\${shell}\" ]; then
    if ! shell=\$(command -v sh 2>/dev/null); then
        shell=\"/bin/sh\"
    fi
fi

sudo \"\${shell}\" -c \"\${RUN_SU}\" \"\${shell##*/}\" \"\$@\""
REMOTE_LOGS="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/logs/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_LOGS()
{
    local _SPACE_NAME=\"_REMOTE_LOGS\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local pod=\"\${1}\"
    shift

    local podVersion=\"\${1}\"
    shift

    local timestamp=\"\${1}\"
    shift

    local limit=\"\${1}\"
    shift

    local streams=\"\${1}\"
    shift

    local podFile=\"\${HOSTHOME}/pods/\${pod}/release/\${podVersion}/pod\"

    if [ ! -f \"\${podFile}\" ]; then
        PRINT \"Missing pod: \${pod}:\${podVersion}\" \"error\" 0
        return 1
    fi

    \${podFile} logs \"\" \"\${tail}\" \"\${since}\"
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_LOGS \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/logs/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/logs/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_DAEMON_LOG="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/daemon_log/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 


{ RUN_SU=\$(cat) ; }<<\"0_SU_SPACEGAL_SAYS_END_OF_FINITY_\"
set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_DAEMON_LOG()
{
    local _SPACE_NAME=\"_REMOTE_DAEMON_LOG\"

    # TODO: add limits and time windows.
    journalctl -u sntd
}

main()
{
    _REMOTE_DAEMON_LOG \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/daemon_log/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/daemon_log/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\"
0_SU_SPACEGAL_SAYS_END_OF_FINITY_

shell=\"\"
if [ -n \"\${BASH_VERSION-}\" ]; then
    shell=\$(command -v bash 2>/dev/null)
fi
if [ -z \"\${shell}\" ]; then
    if ! shell=\$(command -v sh 2>/dev/null); then
        shell=\"/bin/sh\"
    fi
fi

sudo \"\${shell}\" -c \"\${RUN_SU}\" \"\${shell##*/}\" \"\$@\""
REMOTE_CREATE_SUPERUSER="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/create_superuser/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_CREATE_SUPERUSER()
{
    local _SPACE_NAME=\"_REMOTE_CREATE_SUPERUSER\"

    local hosthome=\"\${1}\"
    shift

    local user=\"\${1}\"
    shift

    _OS_CREATE_USER \"\${user}\" &&
    OS_MKSUDO_USER \"\${user}\"
}

_OS_CREATE_USER()
{
    local _SPACE_NAME=\"_OS_CREATE_USER\"

    local targetuser=\"\${1}\"
    shift

    PRINT \"Create \${targetuser}.\" \"debug\"

    # shellcheck disable=2034
    local out_ostype=''
    local out_ospkgmgr=''
    local out_oshome=''
    local out_oscwd=''
    local out_osinit=''
    OS_ID

    # Read pub key from stdin
    local keycontents=\"\$(cat)\"

    local home=\"\${out_oshome}/\${targetuser}\"
    if ! OS_USER_EXIST \"\${targetuser}\"; then
        OS_ADD_USER \"\${targetuser}\" \"\${home}\"
    fi &&
    FILE_CHMOD \"700\" \"\${home}\" &&
    FILE_MKDIRP \"\${home}/.ssh\" &&
    FILE_CHMOD \"700\" \"\${home}/.ssh\" &&
    FILE_ROW_PERSIST \"\${keycontents}\" \"\${home}/.ssh/authorized_keys\" &&
    FILE_CHMOD \"600\" \"\${home}/.ssh/authorized_keys\" &&
    FILE_CHOWNR \"\${targetuser}:\${targetuser}\" \"\${home}/.ssh\"

    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not create user: \${targetuser}.\" \"error\"
        return 1
    fi
}

OS_MKSUDO_USER()
{
    local _SPACE_NAME=\"OS_MKSUDO_USER\"

    local targetuser=\"\${1}\"
    shift

    PRINT \"mksudo \${targetuser}.\" \"debug\"

    OS_GROUP_EXIST \"sudo\"
    if [ \"\$?\" -eq 0 ]; then
        PRINT \"Add user to sudo group.\" \"debug\"
        OS_USER_ADD_GROUP \"\${targetuser}\" \"sudo\"
    fi

    FILE_ROW_PERSIST \"\${targetuser} ALL=(ALL:ALL) NOPASSWD: ALL\" \"/etc/sudoers\"

    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not mksudo user: \${targetuser}.\" \"error\"
        return 1
    fi
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

FILE_CHMOD()
{
    local _SPACE_NAME=\"FILE_CHMOD\"

    local octets=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"chmod \${file} to \${octets}.\" \"debug\"

    chmod \"\${octets}\" \"\${file}\"
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not chmod \${file} to \${octets}.\" \"error\"
        return 1
    fi
}

FILE_MKDIRP()
{
    local _SPACE_NAME=\"FILE_MKDIRP\"

    local dir=\"\$*\"

    PRINT \"Creating directories: \${dir}.\" \"debug\"
    mkdir -p \${dir}
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not create directory: \${dir}.\" \"error\"
        return 1
    fi
}

FILE_ROW_PERSIST()
{
    local _SPACE_NAME=\"FILE_ROW_PERSIST\"

    local row=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"Make sure that row exist in \${file}: \${row}\" \"debug\"

    grep -q \"^\${row}\\\$\" \"\${file}\" 2>/dev/null
    local status=\"\$?\"
    if [ \"\${status}\" = \"2\" ]; then
        PRINT \"File not found: \${file}, create it and add row.\" \"debug\"
        FILE_APPEND_ROW \"\${row}\" \"\${file}\"
    elif [ \"\${status}\" = \"1\" ]; then
        PRINT \"Row does not exist, add row.\" \"debug\"
        FILE_APPEND_ROW \"\${row}\" \"\${file}\"
    fi
}

FILE_CHOWNR()
{
    local _SPACE_NAME=\"FILE_CHOWNR\"

    local owner=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"chown \${file} to \${owner}.\" \"debug\"

    chown -R \"\${owner}\" \"\${file}\"
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not chown -R \${file} to \${owner}.\" \"error\"
        return 1
    fi
}

OS_ID()
{
    local _SPACE_NAME=\"OS_ID\"

    out_ostype=\"gnu\"
    out_oshome=\"/home\"
    out_oscwd=\"\$(pwd)\"
    out_ospkgmgr=
    out_osinit=\"sysvinit\"

    if OS_COMMAND \"systemctl\" >/dev/null; then
        out_osinit=\"systemd\"
    fi

    if [ \"\${out_oscwd}\" = \"/\" ]; then
        # We'll conform the root directory to not end with slash,
        # since other directories do not end with slash.
        out_oscwd=\"/.\"
    fi

    [ -f \"/etc/debian_version\" ] && out_ospkgmgr=\"apt\"
    [ -f \"/etc/arch-release\" ] && out_ospkgmgr=\"pacman\"
    [ -d \"/etc/yum\" ] && out_ospkgmgr=\"yum\"
    [ -f \"/etc/redhat-release\" ] && out_ospkgmgr=\"yum\"
    [ -f \"/etc/alpine-release\" ] && { out_ospkgmgr=\"apk\"; out_ostype=\"busybox\"; }

    # Some releases are more tricky.
    if [ \"\${out_ospkgmgr}\" = \"\" ]; then
        if OS_COMMAND \"apt-get\" >/dev/null; then
            out_ospkgmgr=\"apt\"
        elif OS_COMMAND \"pacman\" >/dev/null; then
            out_ospkgmgr=\"pacman\"
        elif OS_COMMAND \"yum\" >/dev/null; then
            out_ospkgmgr=\"yum\"
        elif OS_COMMAND \"apk\" >/dev/null; then
            out_ospkgmgr=\"apk\"
            # We assume Alpine Linux runs on BusyBox.
            # We could have a more fine grained check,
            # but we would have to execute 'ls' a couple of times to do that.
            out_ostype=\"busybox\"
        elif OS_COMMAND \"brew\" >/dev/null; then
            out_ospkgmgr=\"brew\"
            out_ostype=\"darwin\"
            out_oshome=\"/Users\"
            out_osinit=\"launchd\"
        elif OS_COMMAND \"pkg\" >/dev/null; then
            out_ospkgmgr=\"pkg\"
            out_ostype=\"FreeBSD\"
            out_osinit=\"rc\"
        fi
    fi

    return 0
}

OS_ADD_USER()
{
    local _SPACE_NAME=\"OS_ADD_USER\"

    local targetuser=\"\${1}\"
    shift

    local home=\"\${1}\"
    shift

    local shpath=\"\${1-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    if [ \"\${shpath}\" = \"\" ]; then
        shpath=\"\$(OS_COMMAND bash)\"
        if [ \"\$?\" -gt 0 ]; then
            shpath=\"\$(OS_COMMAND sh)\"
        fi
    fi

    if OS_COMMAND useradd >/dev/null; then
        useradd -m -d \"\${home}\" -s \"\${shpath}\" -U \"\${targetuser}\"
    elif OS_COMMAND adduser >/dev/null; then
        adduser -D -h \"\${home}\" -s \"\${shpath}\" \"\${targetuser}\"
    else
        PRINT \"No useradd/adduser installed.\" \"error\"
        return 1
    fi
}

OS_USER_EXIST()
{
    local _SPACE_NAME=\"OS_USER_EXIST\"

    # shellcheck disable=SC2039
    local targetuser=\"\${1}\"
    shift

    PRINT \"Check if user \${targetuser} exists.\" \"debug\"

    id -u \"\${targetuser}\" >/dev/null 2>&1
    if [ \"\$?\" -eq 0 ]; then
        PRINT \"User does exist.\" \"debug\"
        return 0
    else
        PRINT \"User does not exist.\" \"debug\"
        return 1
    fi
}

OS_USER_ADD_GROUP()
{
    local _SPACE_NAME=\"OS_USER_ADD_GROUP\"

    local targetuser=\"\${1}\"
    shift

    local group=\"\${1}\"
    shift

    if OS_COMMAND usermod >/dev/null; then
        PRINT \"User usermod -Ag to add the user: '\${targetuser}' to the group: '\${group}'\" \"debug\"
        usermod -aG \"\${group}\" \"\${targetuser}\"
    elif OS_COMMAND addgroup >/dev/null; then
        addgroup \"\${targetuser}\" \"\${group}\"
    else
        PRINT \"Nor 'usermod' nor 'addgroup' found, can't add user to group.\" \"error\"
        return 1
    fi
}

OS_GROUP_EXIST()
{
    local _SPACE_NAME=\"OS_GROUP_EXIST\"

    # shellcheck disable=SC2039
    local group=\"\${1}\"
    shift

    PRINT \"Check if group \${group} exists.\" \"debug\"

    FILE_GREP \"^\${group}:.*\\\$\" \"/etc/group\" \"1\" \"ge\" >/dev/null
    if [ \"\$?\" -eq 0 ]; then
        PRINT \"Group does exist.\" \"debug\"
        return 0
    else
        PRINT \"Group does not exist.\" \"debug\"
        return 1
    fi
}

FILE_APPEND_ROW()
{
    local _SPACE_NAME=\"FILE_APPEND_ROW\"

    local data=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"Append row to \${file}.\" \"debug\"

    # We want to make sure that the last byte before the append, if any,
    # is a newline character.
    local newline=\"\"
    if [ -f \"\${file}\" ]; then
        local cr=\"
\"
        local char=
        char=\"\$(tail -c -1 \${file})\"
        if [ \"\${char}\" != \"\" ] && [ \"\${char}\" != \"\${cr}\" ]; then
            newline=\"\${cr}\"
        fi
    fi

    printf \"%s\n\" \"\${newline}\${data}\" | tee -a \"\${file}\" >/dev/null
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not write to \${file}.\" \"error\"
        return 1
    fi
}

OS_COMMAND()
{
    local _SPACE_NAME=\"OS_COMMAND\"

    local cmd=\"\${1}\"
    shift

    command -v \${cmd} >/dev/null
}

FILE_GREP()
{
    local _SPACE_NAME=\"FILE_GREP\"

    local pattern=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    local count=\"\${1-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local operator=\"\${1:-eq}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    PRINT \"Grep on \${file}: \${pattern}\" \"debug\"

    local tmp=
    tmp=\"\$(grep \"\${pattern}\" \"\${file}\" 2>/dev/null)\"
    local status=\"\$?\"
    if [ \"\${status}\" = \"2\" ]; then
        PRINT \"File not found: \${file}.\" \"error\"
        return 2
    fi

    if [ -z \"\${count}\" ]; then
        if [ \"\${status}\" = \"1\" ]; then
            PRINT \"Pattern not matched.\" \"debug\"
            return 1
        else
            printf \"%s\n\" \"\${tmp}\"
        fi
    else
        local count2=0
        local line=
        local IFS=\"
\"
        for line in \${tmp}; do
            count2=\"\$((count2+1))\"
        done
        # shell check can't parse this if statement because of the dynamic comparison operator.
        # shellcheck disable=SC1009
        if [ \"\${count2}\" \"-\${operator}\" \"\${count}\" ]; then
            return 0
        else
            PRINT \"Wrong count: got \${count2}, operator -\${operator}, defined \${count}.\" \"debug\"
            return 1
        fi
    fi
}

main()
{
    _REMOTE_CREATE_SUPERUSER \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/create_superuser/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/create_superuser/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_DISABLE_ROOT="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/disable_root/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 


{ RUN_SU=\$(cat) ; }<<\"0_SU_SPACEGAL_SAYS_END_OF_FINITY_\"
set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_DISABLE_ROOT()
{
    local _SPACE_NAME=\"_REMOTE_DISABLE_ROOT\"

    OS_DISABLE_ROOT
}

OS_DISABLE_ROOT()
{
    local _SPACE_NAME=\"OS_DISABLE_ROOT\"

    PRINT \"Inactivating root account.\" \"debug\"

    #if [ \"\$(id -u)\" -eq 0 ]; then
        #PRINT \"Do not run this as root.\" \"error\"
        #return 1
    #fi

    passwd -d root &&
    FILE_SED \"s/^PermitRootLogin.*\$/PermitRootLogin no/g\" \"/etc/ssh/sshd_config\" &&
    FILE_ROW_PERSIST \"PermitRootLogin no\" \"/etc/ssh/sshd_config\" &&
    OS_SERVICE \"sshd\" \"reload\"

    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not inactivate root.\" \"error\"
        return 1
    fi
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

FILE_SED()
{
    local _SPACE_NAME=\"FILE_SED\"

    local pattern=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"Sed on \${file}: \${pattern}\" \"debug\"

    local tmp=
    tmp=\"\$(sed \"\${pattern}\" \"\${file}\")\"
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not sed \${file}.\" \"error\"
        return 1
    fi
    printf \"%s\n\" \"\${tmp}\" | tee \"\${file}\" >/dev/null
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not write to \${file}.\" \"error\"
        return 1
    fi
}

FILE_ROW_PERSIST()
{
    local _SPACE_NAME=\"FILE_ROW_PERSIST\"

    local row=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"Make sure that row exist in \${file}: \${row}\" \"debug\"

    grep -q \"^\${row}\\\$\" \"\${file}\" 2>/dev/null
    local status=\"\$?\"
    if [ \"\${status}\" = \"2\" ]; then
        PRINT \"File not found: \${file}, create it and add row.\" \"debug\"
        FILE_APPEND_ROW \"\${row}\" \"\${file}\"
    elif [ \"\${status}\" = \"1\" ]; then
        PRINT \"Row does not exist, add row.\" \"debug\"
        FILE_APPEND_ROW \"\${row}\" \"\${file}\"
    fi
}

OS_SERVICE()
{
    local _SPACE_NAME=\"OS_SERVICE\"

    local service=\"\${1}\"
    shift

    local action=\"\${1}\"
    shift

    PRINT \"Service \${service}, \${action}.\" \"info\"

    local out_ostype=''
    local out_ospkgmgr=''
    local out_oshome=''
    local out_oscwd=''
    local out_osinit=''
    OS_ID

    if [ \"\${out_osinit}\" = \"systemd\" ]; then
        systemctl \"\${action}\" \"\${service}\"
    elif [ \"\${out_osinit}\" = \"sysvinit\" ]; then
        \"/etc/init.d/\${service}\" \"\${action}\"
    elif [ \"\${out_osinit}\" = \"launchd\" ]; then
        launchctl \"\${action}\" \"\${service}\"
    elif [ \"\${out_osinit}\" = \"rc\" ]; then
        \"/etc/rc.d/\${service}\" \"\${action}\"
    else
        PRINT \"Could not determine what init service is being used in the OS.\" \"error\"
        return 1
    fi
}

FILE_APPEND_ROW()
{
    local _SPACE_NAME=\"FILE_APPEND_ROW\"

    local data=\"\${1}\"
    shift

    local file=\"\${1}\"
    shift

    PRINT \"Append row to \${file}.\" \"debug\"

    # We want to make sure that the last byte before the append, if any,
    # is a newline character.
    local newline=\"\"
    if [ -f \"\${file}\" ]; then
        local cr=\"
\"
        local char=
        char=\"\$(tail -c -1 \${file})\"
        if [ \"\${char}\" != \"\" ] && [ \"\${char}\" != \"\${cr}\" ]; then
            newline=\"\${cr}\"
        fi
    fi

    printf \"%s\n\" \"\${newline}\${data}\" | tee -a \"\${file}\" >/dev/null
    if [ \"\$?\" -gt 0 ]; then
        PRINT \"Could not write to \${file}.\" \"error\"
        return 1
    fi
}

OS_ID()
{
    local _SPACE_NAME=\"OS_ID\"

    out_ostype=\"gnu\"
    out_oshome=\"/home\"
    out_oscwd=\"\$(pwd)\"
    out_ospkgmgr=
    out_osinit=\"sysvinit\"

    if OS_COMMAND \"systemctl\" >/dev/null; then
        out_osinit=\"systemd\"
    fi

    if [ \"\${out_oscwd}\" = \"/\" ]; then
        # We'll conform the root directory to not end with slash,
        # since other directories do not end with slash.
        out_oscwd=\"/.\"
    fi

    [ -f \"/etc/debian_version\" ] && out_ospkgmgr=\"apt\"
    [ -f \"/etc/arch-release\" ] && out_ospkgmgr=\"pacman\"
    [ -d \"/etc/yum\" ] && out_ospkgmgr=\"yum\"
    [ -f \"/etc/redhat-release\" ] && out_ospkgmgr=\"yum\"
    [ -f \"/etc/alpine-release\" ] && { out_ospkgmgr=\"apk\"; out_ostype=\"busybox\"; }

    # Some releases are more tricky.
    if [ \"\${out_ospkgmgr}\" = \"\" ]; then
        if OS_COMMAND \"apt-get\" >/dev/null; then
            out_ospkgmgr=\"apt\"
        elif OS_COMMAND \"pacman\" >/dev/null; then
            out_ospkgmgr=\"pacman\"
        elif OS_COMMAND \"yum\" >/dev/null; then
            out_ospkgmgr=\"yum\"
        elif OS_COMMAND \"apk\" >/dev/null; then
            out_ospkgmgr=\"apk\"
            # We assume Alpine Linux runs on BusyBox.
            # We could have a more fine grained check,
            # but we would have to execute 'ls' a couple of times to do that.
            out_ostype=\"busybox\"
        elif OS_COMMAND \"brew\" >/dev/null; then
            out_ospkgmgr=\"brew\"
            out_ostype=\"darwin\"
            out_oshome=\"/Users\"
            out_osinit=\"launchd\"
        elif OS_COMMAND \"pkg\" >/dev/null; then
            out_ospkgmgr=\"pkg\"
            out_ostype=\"FreeBSD\"
            out_osinit=\"rc\"
        fi
    fi

    return 0
}

OS_COMMAND()
{
    local _SPACE_NAME=\"OS_COMMAND\"

    local cmd=\"\${1}\"
    shift

    command -v \${cmd} >/dev/null
}

main()
{
    _REMOTE_DISABLE_ROOT \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/disable_root/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/disable_root/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\"
0_SU_SPACEGAL_SAYS_END_OF_FINITY_

shell=\"\"
if [ -n \"\${BASH_VERSION-}\" ]; then
    shell=\$(command -v bash 2>/dev/null)
fi
if [ -z \"\${shell}\" ]; then
    if ! shell=\$(command -v sh 2>/dev/null); then
        shell=\"/bin/sh\"
    fi
fi

sudo \"\${shell}\" -c \"\${RUN_SU}\" \"\${shell##*/}\" \"\$@\""
REMOTE_SIGNAL="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/signal/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_SIGNAL()
{
    local _SPACE_NAME=\"_REMOTE_SIGNAL\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local pod=\"\${1}\"
    shift

    local podVersion=\"\${1}\"
    shift

    local podFile=\"\${HOSTHOME}/pods/\${pod}/release/\${podVersion}/pod\"

    if [ ! -f \"\${podFile}\" ]; then
        PRINT \"Missing pod: \${pod}:\${podVersion}\" \"error\" 0
        return 1
    fi

    \${podFile} signal \"\$@\"
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_SIGNAL \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/signal/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/signal/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_POD_STATUS="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/pod_status/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_POD_STATUS()
{
    local _SPACE_NAME=\"_REMOTE_POD_STATUS\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local pod=\"\${1}\"
    shift

    local podVersion=\"\${1}\"
    shift

    local query=\"\${1}\"
    shift

    local podFile=\"\${HOSTHOME}/pods/\${pod}/release/\${podVersion}/pod\"

    if [ ! -f \"\${podFile}\" ]; then
        PRINT \"Missing pod: \${pod}:\${podVersion}\" \"error\" 0
        return 10
    fi

    if [ \"\${query}\" = \"readiness\" ]; then
        if \${podFile} readiness; then
            printf \"ready\\n\"
        else
            printf \"not-ready\\n\"
        fi
    else
        \${podFile} status
    fi
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_POD_STATUS \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/pod_status/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/pod_status/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_POD_SHELL="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/pod_shell/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_POD_SHELL()
{
    local _SPACE_NAME=\"_REMOTE_POD_SHELL\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local pod=\"\${1}\"
    shift

    local podVersion=\"\${1}\"
    shift

    local container=\"\${1}\"
    shift

    local useBash=\"\${1:-false}\"
    shift

    local podFile=\"\${HOSTHOME}/pods/\${pod}/release/\${podVersion}/pod\"

    if [ ! -f \"\${podFile}\" ]; then
        PRINT \"Missing pod: \${pod}:\${podVersion}\" \"error\" 0
        return 10
    fi

    if [ \"\${useBash}\" = \"true\" ]; then
        \${podFile} \"shell\" \"\${container}\" -B
    else
        \${podFile} \"shell\" \"\${container}\"
    fi
}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_POD_SHELL \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/pod_shell/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/pod_shell/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
REMOTE_HOST_SHELL="#!/usr/bin/env sh
# Script assembled and exported by:
#     ___ ___  ___  ____ ____  ___ __ __
#    / __/ _ \/ _ |/ ___/ __/ / __/ // /
#   _\ \/ ___/ __ / /__/ _/_ _\ \/ _  /
#  /___/_/  /_/ |_\___/___(_)___/_//_/
#  version: 1.3.0 | https://space.sh
#
# Node: /_remote_plumbing/host_shell/
# Simplenetes version 0.1
# A set of commands used only for when compiling a release of this module into a standalone script file.
# 

set -u  # Will not allow for unset variables being used.

SPACE_LOG_LEVEL=\"\${SPACE_LOG_LEVEL:-4}\"
SPACE_LOG_ENABLE_COLORS=\"\${SPACE_LOG_ENABLE_COLORS:-1}\"
SPACE_ASSERT_EXIT=\"\${SPACE_ASSERT_EXIT:-0}\"
SPACE_MUTE_EXIT=\"\${SPACE_MUTE_EXIT:-0}\"
SPACE_MUTE_EXIT_MESSAGE=\"\${SPACE_MUTE_EXIT_MESSAGE:-1}\"
_REMOTE_HOST_SHELL()
{
    local _SPACE_NAME=\"_REMOTE_HOST_SHELL\"

    local HOSTHOME=\"\${1}\"
    shift
    if [ \"\$(STRING_SUBSTR \"\${HOSTHOME}\" 0 1)\" != '/' ]; then
        HOSTHOME=\"\$(FILE_REALPATH \"\${HOME}/\${HOSTHOME}\")\"
    fi

    local useBash=\"\${1:-false}\"
    shift

    cd \"\${HOSTHOME}\"

    if [ \"\${useBash}\" = \"true\" ]; then
        bash
    else
        sh
    fi

}

STRING_SUBSTR()
{
    local _SPACE_NAME=\"STRING_SUBSTR\"

    # shellcheck disable=SC2034
    local __sopriv=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __length=\"\${1}\"
    shift

    local __outvar=\"\${1:-}\"
    shift \$(( \$# > 0 ? 1 : 0 ))

    local __strlength=\"\${#__sopriv}\"

    if [ \"\${__index}\" -lt 0 ]; then
        __index=\$((__strlength+__index))
    fi

    if [ \"\${__index}\" -ge 0 ]; then
        if [ \"\${__length}\" = \"\" ]; then
            __length=\$((__strlength-__index))
        fi

        if [ \"\${__length}\" -lt 0 ]; then
            __length=\$((__strlength-__index+__length))
        fi

        if [ \"\$((__index+__length))\" -le \"\${#__sopriv}\" ]; then
            local __wildcard=
            STRING_REPEAT \"?\" \"\${__index}\" \"\" \"__wildcard\"
            local __substr=\"\${__sopriv#\${__wildcard}}\"
            STRING_REPEAT \"?\" \"\$((\${#__substr}-__length))\" \"\" \"__wildcard\"
            __substr=\"\${__substr%\${__wildcard}}\"
            if [ -n \"\${__outvar}\" ]; then
                eval \"\${__outvar}=\\\"\\\${__substr}\\\"\"
            else
                printf \"%s\\n\" \"\${__outvar}\"
            fi
            return 0
        fi

    fi

    if [ -n \"\${__outvar}\" ]; then
        eval \"\${__outvar}=\\\"\\\"\"
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME=\"FILE_REALPATH\"

    local file=\"\${1}\"
    shift

    local pwd=\"\${1:-\$PWD}\"

    if [ \"\${file#/}\" != \"\${file}\" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file=\"\${pwd}/\${file}\"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs=\"\${IFS}\"
        local IFS=\"/\"
        STRING_ITEM_COUNT \"\${file}\" \"count\"
        IFS=\${_ifs}
        local index=-1
        local keepIndexes=\"\"
        while [ \"\${index}\" -lt \"\$((count-1))\" ]; do
            index=\"\$((index+1))\"
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            if [ -z \"\${item}\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \".\" ]; then
                # Discard it
                continue
            elif [ \"\${item}\" = \"..\" ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes=\"\${keepIndexes%[ ]*}\"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes=\"\${keepIndexes} \${index}\"
        done
        # Put together the file again
        local file2=
        for index in \${keepIndexes}; do
            local _ifs=\"\${IFS}\"
            IFS=\"/\"
            STRING_ITEM_GET \"\${file}\" \"\${index}\" \"item\"
            IFS=\${_ifs}
            file2=\"\${file2}/\${item}\"
        done
        if [ \"\${file}\" = \"\${file2}\" ]; then
            # We are done
            file=\"\${file2}\"
            break
        fi
        file=\"\${file2}\"
    done
    file=\"\${file:-/}\"

    printf \"%s\\n\" \"\${file}\"
}

PRINT()
{
    local color=''
    local header=''
    [ \"\${3:-1}\" = 1 ] && {
        local _SPACE_NAME=\"\${_SPACE_NAME:-anonymous}: \";
    } || {
        local _SPACE_NAME=\"\";
    }

    case \"\${2:-info}\" in
        error)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[ERROR] \"; color=\"\033[31m\"
            ;;
        security)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 1 ]; then return; fi
            header=\"[SEC]   \"; color=\"\033[35m\"
            ;;
        warning)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 2 ]; then return; fi
            header=\"[WARN]  \"; color=\"\033[33m\"
            ;;
        ok)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 3 ]; then return; fi
            header=\"[OK]    \"; color=\"\033[32m\"
            ;;
        info)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 4 ]; then return; fi
            header=\"[INFO]  \"; color=\"\033[37m\"
            ;;
        debug)
            if [ \"\${SPACE_LOG_LEVEL:-4}\" -lt 5 ]; then return; fi
            header=\"[DEBUG] \"; color=\"\"
            ;;
        *)
            return
            ;;
    esac
    if [ \"\${SPACE_LOG_ENABLE_COLORS}\" = \"1\" ] && [ -t 2 ]; then
        printf \"\${color}%s%s%s\033[0m\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    else
        printf \"%s%s%s\n\" \"\${header}\" \"\${_SPACE_NAME}\" \"\${1}\" >&2
    fi
}

STRING_REPEAT()
{
    local _SPACE_NAME=\"STRING_REPEAT\"

    local __string=\"\${1}\"
    shift

    local __count=\"\${1}\"
    shift

    local __separator=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __repeatedstring=\"\"
    while [ \"\${__count}\" -gt 0 ]; do
        __count=\$((__count-1))
        __repeatedstring=\"\${__repeatedstring}\${__string}\"
        if [ \"\${__count}\" -gt 0 ]; then
            __repeatedstring=\"\${__repeatedstring}\${__separator}\"
        fi
    done

    eval \"\${__outvar}=\\\"\\\${__repeatedstring}\\\"\"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME=\"STRING_ITEM_COUNT\"

    local __s=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        __count=\$((__count+1))
    done
    eval \"\${__outvar}=\\\"\\\${__count}\\\"\"
}

STRING_ITEM_GET()
{
    local _SPACE_NAME=\"STRING_ITEM_GET\"

    local __s=\"\${1}\"
    shift

    local __index=\"\${1}\"
    shift

    local __outvar=\"\${1}\"
    shift

    local __item=
    local __count=0
    for __item in \${__s}; do
        if [ \"\${__count}\" -eq \"\${__index}\" ]; then
            eval \"\${__outvar}=\\\"\\\${__item}\\\"\"
            break
        fi
        __count=\$((__count+1))
    done
}

main()
{
    _REMOTE_HOST_SHELL \"\$@\"

    # Space will print exit status.
    local _status=\$?
    if [ \"\${_status}\" -ne \"\${SPACE_ASSERT_EXIT}\" ]; then
        if [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 1 ]; then
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[31m\" >&2
            printf \"%s\n\" \"[ERROR] Script exited with status \$_status for node /_remote_plumbing/host_shell/\" >&2
            [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ -t 2 ] && printf \"\033[0m\" >&2
        fi
        if [ \"\${SPACE_MUTE_EXIT}\" != 1 ]; then
            return \$((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ \"\${SPACE_MUTE_EXIT_MESSAGE}\" != \"1\" ] && [ \"\${SPACE_LOG_LEVEL}\" -ge 5 ]; then
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[32m\" >&2
        printf \"%s\n\" \"[DEBUG] Script exited with success (status \$_status) for node /_remote_plumbing/host_shell/\" >&2
        [ \"\${SPACE_LOG_ENABLE_COLORS:-1}\" = \"1\" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf \"\033[0m\" >&2
        : # Important to reset status here.
    fi
}

main \"\$@\""
SPACE_LOG_LEVEL="${SPACE_LOG_LEVEL:-4}"
SPACE_LOG_ENABLE_COLORS="${SPACE_LOG_ENABLE_COLORS:-1}"
SPACE_ASSERT_EXIT="${SPACE_ASSERT_EXIT:-0}"
SPACE_MUTE_EXIT="${SPACE_MUTE_EXIT:-0}"
SPACE_MUTE_EXIT_MESSAGE="${SPACE_MUTE_EXIT_MESSAGE:-1}"
SNT_CMDLINE()
{
    local _SPACE_NAME="SNT_CMDLINE"

    if [ "${1:-help}" = "help" ]; then
        USAGE
        return
    elif [ "${1:-}" = "-h" ]; then
        USAGE
        return
    elif [ "${1:-}" = "version" ]; then
        VERSION
        return
    elif [ "${1:-}" = "-V" ]; then
        VERSION
        return
    fi

    local oldCwd="${PWD}"

    # Check for cluster-id.txt, upwards and cd into that dir so that snt becomes more flexible in where users execute it from.
    # If we are inside CLUSTERPATH, but there is no cluster-id.txt, then we can conclude that CLUSTERPATH=$PWD, and we allow to check upward for a cluster-id.txt
    local dots="./"
    if [ ! -f "cluster-id.txt" ] && [ "${CLUSTERPATH}" = "${PWD}" ]; then
        PRINT "CLUSTERPATH not valid, searching upwards for cluster-id.txt" "debug"
        while true; do
            while [ "$(FILE_REALPATH "${dots}")" != "/" ]; do
                dots="../${dots}"
                if [ -f "${dots}/cluster-id.txt" ]; then
                    # Found it
                    CLUSTERPATH="$(FILE_REALPATH "${dots}")"
                    PRINT "Setting new CLUSTERPATH: ${CLUSTERPATH}" "debug"
                    if [ ! -d "${PODPATH}" ]; then
                        PODPATH="$(FILE_REALPATH "${CLUSTERPATH}/../pods")"
                        PRINT "Setting new PODPATH: ${PODPATH}" "debug"
                    fi
                    break 2
                fi
            done
            PRINT "No cluster project detected, cannot continue" "error" 0
            return 1
        done
    fi

    local status=
    _SNT_CMDLINE "$@"
    status="$?"

    cd "${oldCwd}"
    return "${status}"
}

USAGE()
{
    local _SPACE_NAME="USAGE"
    printf "%s\\n" "Usage:
    help
    -h
        Output this help

    version
    -V
        Output the version of snt

    create-cluster name
        Creates a cluster project with the given name in the current directory.

    sync [-f] [-q]
        Sync the cluster project in the current directory with the Cluster
        -f switch set then a force sync is performed. This is useful when performing a rollback
            or if restoring a previous branch-out.
        -q set to be more quite.

    status
        Output status of the Cluster

    import-config pod
        Import config templates from pod repo into the cluster project

    create-host host [-j jumpHost] [-e expose] [-h hostHome]
        Create a host in the cluster repo by the name 'host'.
        -j jumphost is an optional host to do SSH jumps via, often used for worker machines which are not exposed directly to the public internet.
            If jumphost is set to 'local' then that dictates this host is not SSH enabled but targets local disk instead.
        -e expose can be a comma separated list of ports we want to expose to the public internet. If not provided then the host will be accessible internally only.
        -h hostHome can be specified

    init-host host
        Initialize a host to be part of the cluster and configure the Daemon to manage it's pods

    setup-host host
        Setup the host using the superuser
        Creates the regular user, installs podman, configures firewalld, etc.

    create-superuser host [-k keyfile]
        Login as root on the host and create the super user as defined in the host.env file.
        rootkeyfile is optional, of not set then password is required to login as root.

    disable-root host
        Use the super user account to disable the root login on a host

    ls-hosts [-a] [-s]
        List active and inactive hosts in this cluster project
        -a if set then also list disabled hosts
        -s if set then add a status column to the output

    ls-pods
        List all known pods in the PODPATH

    ls-hosts-by-pod pod
        List all hosts who have a given pod attached

    ls-pods-by-host host
        List all pods attached to a specific host

    attach-pod pod@host
        Attach a Pod to a host, this does not deploy anything nor release anything
        host must exist in the cluster project
        pod must exist on PODPATH

    detach-pod pod[@host]
        Remove a pod from one or all hosts

    compile pod[@host] [-v]
        Compile the current pod version to all (or one) host(s) which it is already attached to.
        If host is left out then compile on all hosts which have the pod attached.
        If -v option set then output the pod version to stdout

    update-config pod[:version][@host]
        Re-copy the pod config in the cluster to a specific pod release.
        If host is left out then copy configs to all hosts which have the pod attached.
        If version is left out the 'latest' version is searched for.

    set-pod-ingress pod[:version][@host] -s active|inactive
        Set ingress active or inactive of a specific pod version on one/all attached hosts.
        If version is left out the 'latest' version is searched for.
        If host is left out then set state for pod on all hosts which the pod is attached to.
        Multiple pods can be given on cmd line.

    set-pod-state pod[:version][@host] -s running|stopped|removed
        Set the desired state of a specific pod version on one/all attached hosts.
        If version is left out the 'latest' version is searched for.
        If host is left out then set state for pod on all hosts which the pod is attached to.
        Multiple pods can be given on cmd line.

    get-pod-state pod[:version][@host]
        Get the desired state of a specific pod version on one/all attached hosts.
        If host is left out then get state of pod for all hosts which the pod is attached to.
        If version is left out the 'latest' version is searched for.

    ls-pod-state pod[@host] [-q] [-s running|stopped|removed]
        Output the desired state for all pod version on all or just the specified host.
        -q, if set then do not output the state column
        -s, if set then filter for the provided state

    get-pod-status pod[:version][@host] [-q] [-r]
        Get the actual status of a pod (not the desired state).
        If host is left out then get status of the pod for all hosts which the pod is attached to.
        If version is left out the 'latest' version is searched for.
        -r option set means to only get the 'readiness' of the pod.
        -q option set means to not output but to return 1 if no pod ready. Only applicable if also -r flag used.

    generate-ingress [ingresspod[:version]] [-x excludeClusterPorts]
        Update the ingress load balancers config by looking at the ingress of all active pod instances on all hosts.
        ingressPod
            name of the ingress pod, defaults to 'ingress'.
            If version is left out the 'latest' version is searched for.
        -x excludeClusterPorts
            Comma separated string of clusterPorts to exclude from the Ingress configuration

    set-host-state host -s active|inactive|disabled

    get-host-state host
        Get the state of a host

    logs pod[:version][@host] [-t timestamp] [-l limit] [-s stdout|stderr]
        Get logs for a pod on one or all attached hosts.
        If version is left out the 'latest' version is searched for.
        If host is left out then get logs for all attached hosts.
        -t timestamp is UNIX timestamp to get from, 0 get's all.
        -l limit is the maximum number of lines to get, negative gets from bottom (newest)
        -s streams is to get stdout, stderr or both, as: -s stdout | -s stderr | -s stdout,stderr (default)

    signal pod[:version][@host] [container]
        Signal a pod on a specific host or on all attached hosts.
        Optionally specify which containers to signal, defualt is all containers in the pod.

    delete pod[:version][@host]
        Delete pod releases which are in the \"removed\" state.
        If version is left out the 'latest' version is searched for.
        If host is left out then delete pod release version for all attached hosts.

    release pod[:version] [-p] [-m soft|hard] [-f]
        Perform the compilation and release of a new pod version.
        This operation expects there to be an Ingress Pod names 'ingress'.
        If 'version' is not provided (or set to 'latest') then compile a new version, if no new version is available quit.
        If 'version' is defined then re-release that version (which is expected have been compiled already).
        -m mode is either soft or hard. Default is hard (quickest).
        -p if set then perform 'git push' operations after each 'git commit'.
        -f if set will force sync changes to cluster

    daemon-log [host]
        Get the systemd unit daemon log

    pod-shell pod[:version][@host] [-c container] [-B]
        Step into a shell inside a container of a pod.
        If version is left out the 'latest' version is searched for.
        If host is left out then enter the container on each host, in sequential order.
        -c option states the name of the container to enter.
           If not set then the last container of the pod is entered (as defined in the pod.yaml).
        -B set to force the use of bash as shell, otherwise uses sh.

    host-shell host [-s] [-B]
        Step into a shell inside a specific host.
        -s option dictates if to enter as the superuser.
        -B set to force the use of bash as shell, otherwise uses sh.
" >&2
}

VERSION()
{
    local _SPACE_NAME="VERSION"
    printf "%s\\n" "Simplenetes version 0.1 (GandalfVsHeman)"
}

_SNT_CMDLINE()
{
    local _SPACE_NAME="_SNT_CMDLINE"

    local action="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    if [ "${action}" = "create-cluster" ]; then
        local _out_rest=
        if ! _GETOPTS "" "" 1 1 "$@"; then
            printf "Usage: snt create-cluster name\\n" >&2
            return 1
        fi
        CLUSTER_CREATE "${_out_rest}"
    elif [ "${action}" = "sync" ]; then
        local _out_f="false"
        local _out_q="false"

        if ! _GETOPTS "f q" "" 0 0 "$@"; then
            printf "Usage: snt sync [-f] [-q]\\n" >&2
            return 1
        fi

        CLUSTER_SYNC "${_out_f}" "${_out_q}"
    elif [ "${action}" = "status" ]; then
        if ! _GETOPTS "" "" 0 0 "$@"; then
            printf "Usage: snt status\\n" >&2
            return 1
        fi
        CLUSTER_STATUS
    elif [ "${action}" = "import-config" ]; then
        local _out_rest=
        if ! _GETOPTS "" "" 1 1 "$@"; then
            printf "Usage: snt import-config pod\\n" >&2
            return 1
        fi
        CLUSTER_IMPORT_POD_CFG "${_out_rest}"
    elif [ "${action}" = "create-host" ]; then
        local _out_j=
        local _out_e=
        local _out_h=
        local _out_rest=
        if ! _GETOPTS "" "j e r h" 1 1 "$@"; then
            printf "Usage: snt create-host host [-j jumpHost] [-e expose [-h hostHome]]\\n" >&2
            return 1
        fi
        HOST_CREATE "${_out_rest}" "${_out_j}" "${_out_e}" "${_out_h}"
    elif [ "${action}" = "init-host" ]; then
        local _out_f="false"
        local _out_rest=

        if ! _GETOPTS "f" "" 1 1 "$@"; then
            printf "Usage: snt init-host host [-f]\\n" >&2
            return 1
        fi
        HOST_INIT "${_out_rest}" "${_out_f}"
    elif [ "${action}" = "setup-host" ]; then
        local _out_rest=

        if ! _GETOPTS "" "" 1 1 "$@"; then
            printf "Usage: snt setup-host host\\n" >&2
            return 1
        fi
        HOST_SETUP "${_out_rest}"
    elif [ "${action}" = "create-superuser" ]; then
        local _out_k=
        local _out_rest=

        if ! _GETOPTS "" "k" 1 1 "$@"; then
            printf "Usage: snt create-superuser host [-k keyfile]\\n" >&2
            return 1
        fi
        HOST_CREATE_SUPERUSER "${_out_rest}" "${_out_k}"
    elif [ "${action}" = "disable-root" ]; then
        local _out_rest=

        if ! _GETOPTS "" "" 1 1 "$@"; then
            printf "Usage: snt disable-root host\\n" >&2
            return 1
        fi
        HOST_DISABLE_ROOT "${_out_rest}"
    elif [ "${action}" = "ls-hosts" ]; then
        local _out_a="false"
        local _out_s="false"

        if ! _GETOPTS "a s" "" 0 0 "$@"; then
            printf "Usage: snt ls-hosts [-a] [-s]\\n" >&2
            return 1
        fi
        LIST_HOSTS "${_out_a}" "${_out_s}"
    elif [ "${action}" = "ls-pods" ]; then
        if ! _GETOPTS "" "" 0 0 "$@"; then
            printf "Usage: snt ls-pods\\n" >&2
            return 1
        fi
        LIST_PODS
    elif [ "${action}" = "ls-hosts-by-pod" ]; then
        local _out_rest=

        if ! _GETOPTS "" "" 1 1 "$@"; then
            printf "Usage: snt ls-hosts-by-pod pod\\n" >&2
            return 1
        fi
        LIST_HOSTS_BY_POD "${_out_rest}"
    elif [ "${action}" = "ls-pods-by-host" ]; then
        local _out_rest=

        if ! _GETOPTS "" "" 1 1 "$@"; then
            printf "Usage: snt ls-pods-by-host host\\n" >&2
            return 1
        fi
        LIST_PODS_BY_HOST "${_out_rest}"
    elif [ "${action}" = "attach-pod" ]; then
        local _out_rest=

        if ! _GETOPTS "" "" 1 1 "$@"; then
            printf "Usage: snt attach-pod pod@host\\n" >&2
            return 1
        fi
        ATTACH_POD "${_out_rest}"
    elif [ "${action}" = "detach-pod" ]; then
        local _out_rest=

        if ! _GETOPTS "" "" 1 1 "$@"; then
            printf "Usage: snt detach-pod host[@pod]\\n" >&2
            return 1
        fi
        DETACH_POD "${_out_rest}"
    elif [ "${action}" = "compile" ]; then
        local _out_v="false"
        local _out_rest=

        if ! _GETOPTS "v" "" 1 1 "$@"; then
            printf "Usage: snt compile-pod pod[@host]\\n" >&2
            return 1
        fi
        COMPILE_POD "${_out_rest}" "${_out_v}"
    elif [ "${action}" = "update-config" ]; then
        local _out_rest=

        if ! _GETOPTS "" "" 1 1 "$@"; then
            printf "Usage: snt update-config pod[:version][@host]\\n" >&2
            return 1
        fi
        UPDATE_POD_CONFIG "${_out_rest}"
    elif [ "${action}" = "set-pod-ingress" ]; then
        local _out_rest=
        local _out_s=""

        if ! _GETOPTS "" "s" 1 999 "$@"; then
            printf "Usage: snt set-pod-ingress pod[:version][@host] -s active|inactive\\n" >&2
            return 1
        fi
        set -- ${_out_rest}
        SET_POD_INGRESS_STATE "${_out_s}" "$@"
    elif [ "${action}" = "set-pod-state" ]; then
        local _out_rest=
        local _out_s=""

        if ! _GETOPTS "" "s" 1 999 "$@"; then
            printf "Usage: snt set-pod-state pod[:version][@host] -s running|stopped|removed\\n" >&2
            return 1
        fi
        set -- ${_out_rest}
        SET_POD_RELEASE_STATE "${_out_s}" "$@"
    elif [ "${action}" = "get-pod-state" ]; then
        local _out_rest=
        local _out_q="false"

        if ! _GETOPTS "q" "" 1 1 "$@"; then
            printf "Usage: snt get-pod-state pod[:version][@host] [-q]\\n" >&2
            return 1
        fi
        GET_POD_RELEASE_STATES "${_out_rest}" "${_out_q}"
    elif [ "${action}" = "ls-pod-state" ]; then
        local _out_rest=
        local _out_q="false"
        local _out_s=""

        if ! _GETOPTS "q" "s" 1 1 "$@"; then
            printf "Usage: snt ls-pod-state pod[@host] [-q] [-s running|stopped|removed]\\n" >&2
            return 1
        fi
        set -- ${_out_rest}
        LS_POD_RELEASE_STATE "${_out_s}" "${_out_q}" "$@"
    elif [ "${action}" = "get-pod-status" ]; then
        local _out_rest=
        local _out_q="false"
        local _out_r="false"

        if ! _GETOPTS "q r" "" 1 1 "$@"; then
            printf "Usage: snt get-pod-status pod[:version][@host] [-q] [-r]\\n" >&2
            return 1
        fi
        set -- ${_out_rest}
        GET_POD_STATUS "${_out_r}" "${_out_q}" "$@"
    elif [ "${action}" = "signal" ]; then
        local _out_rest=

        if ! _GETOPTS "" "" 1 999 "$@"; then
            printf "Usage: snt signal pod[:version][@host] [container]\\n" >&2
            return 1
        fi
        set -- ${_out_rest}
        SIGNAL_POD "$@"
    elif [ "${action}" = "delete" ]; then
        local _out_rest=

        if ! _GETOPTS "" "" 1 999 "$@"; then
            printf "Usage: snt delete pod[:version][@host]\\n" >&2
            return 1
        fi
        set -- ${_out_rest}
        DELETE_POD "$@"
    elif [ "${action}" = "logs" ]; then
        local _out_rest=
        local _out_t="0"
        local _out_l="0"
        local _out_s="stdout,stderr"

        if ! _GETOPTS "" "t l s" 1 1 "$@"; then
            printf "Usage: snt logs pod[:version][@host] [-t timestamp] [-l limit] [-s streams]\\n" >&2
            return 1
        fi
        set -- ${_out_rest}
        LOGS "${_out_t}" "${_out_l}" "${_out_s}" "$@"
    elif [ "${action}" = "daemon-log" ]; then
        local _out_rest=
        if ! _GETOPTS "" "" 0 1 "$@"; then
            printf "Usage: snt daemon-log [host]\\n" >&2
            return 1
        fi
        DAEMON_LOG "${_out_rest}"
    elif [ "${action}" = "generate-ingress" ]; then
        local _out_rest=
        local _out_x=
        if ! _GETOPTS "" "x" 0 1 "$@"; then
            printf "Usage: snt generate-ingress [ingressPod[:version]] [-x excludeClusterPorts]\\n" >&2
            return 1
        fi
        GEN_INGRESS_CONFIG "${_out_rest}" "${_out_x}"
    elif [ "${action}" = "set-host-state" ]; then
        local _out_rest=
        local _out_s=""
        if ! _GETOPTS "" "s" 1 1 "$@"; then
            printf "Usage: snt set-host-state host -s active|inactive|disabled\\n" >&2
            return 1
        fi
        set -- ${_out_rest}
        SET_HOST_STATE "${_out_s}" "$@"
    elif [ "${action}" = "get-host-state" ]; then
        local _out_rest=
        if ! _GETOPTS "" "" 1 1 "$@"; then
            printf "Usage: snt get-host-state host\\n" >&2
            return 1
        fi
        GET_HOST_STATE "${_out_rest}"
    elif [ "${action}" = "release" ]; then
        local _out_rest=
        local _out_m="hard"
        local _out_p="false"
        local _out_f="false"

        if ! _GETOPTS "p f" "m" 1 1 "$@"; then
            printf "Usage: snt release pod[:version] [-p] [-m soft|hard] [-f]\\n" >&2
            return 1
        fi
        RELEASE "${_out_rest}" "${_out_m}" "${_out_p}" "${_out_f}"
    elif [ "${action}" = "pod-shell" ]; then
        local _out_rest=
        local _out_c=""
        local _out_B="false"

        if ! _GETOPTS "B" "c" 1 1 "$@"; then
            printf "Usage: snt pod-shell pod[:version][@host] [-c container] [-B]\\n" >&2
            return 1
        fi
        set -- ${_out_rest}
        POD_SHELL "${1}" "${_out_s}" "${_out_B}"
    elif [ "${action}" = "host-shell" ]; then
        local _out_rest=
        local _out_s="false"
        local _out_B="false"

        if ! _GETOPTS "s B" "" 1 1 "$@"; then
            printf "Usage: snt host-shell host [-s] [-B]\\n" >&2
            return 1
        fi
        set -- ${_out_rest}
        HOST_SHELL "${1}" "${_out_s}" "${_out_B}"
    else
        PRINT "Unknown command" "error" 0
        return 1
    fi
}

FILE_REALPATH()
{
    local _SPACE_NAME="FILE_REALPATH"

    local file="${1}"
    shift

    local pwd="${1:-$PWD}"

    if [ "${file#/}" != "${file}" ]; then
        # Already absolute
        # Fall through for cleaning swipe
        :
    else
        # Prepend the current directory.
        file="${pwd}/${file}"
    fi

    # Remove dots and act on double dots.
    local count=
    local item=
    while true; do
        local _ifs="${IFS}"
        local IFS="/"
        STRING_ITEM_COUNT "${file}" "count"
        IFS=${_ifs}
        local index=-1
        local keepIndexes=""
        while [ "${index}" -lt "$((count-1))" ]; do
            index="$((index+1))"
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            if [ -z "${item}" ]; then
                # Discard it
                continue
            elif [ "${item}" = "." ]; then
                # Discard it
                continue
            elif [ "${item}" = ".." ]; then
                # Discard this one, and also the previous one
                # Cut away last keep index
                keepIndexes="${keepIndexes%[ ]*}"
                continue
            fi
            # Keep this one. The space here is important in all cases due to how it is cut above.
            keepIndexes="${keepIndexes} ${index}"
        done
        # Put together the file again
        local file2=
        for index in ${keepIndexes}; do
            local _ifs="${IFS}"
            IFS="/"
            STRING_ITEM_GET "${file}" "${index}" "item"
            IFS=${_ifs}
            file2="${file2}/${item}"
        done
        if [ "${file}" = "${file2}" ]; then
            # We are done
            file="${file2}"
            break
        fi
        file="${file2}"
    done
    file="${file:-/}"

    printf "%s\\n" "${file}"
}

PRINT()
{
    local color=''
    local header=''
    [ "${3:-1}" = 1 ] && {
        local _SPACE_NAME="${_SPACE_NAME:-anonymous}: ";
    } || {
        local _SPACE_NAME="";
    }

    case "${2:-info}" in
        error)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[ERROR] "; color="\033[31m"
            ;;
        security)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 1 ]; then return; fi
            header="[SEC]   "; color="\033[35m"
            ;;
        warning)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 2 ]; then return; fi
            header="[WARN]  "; color="\033[33m"
            ;;
        ok)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 3 ]; then return; fi
            header="[OK]    "; color="\033[32m"
            ;;
        info)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 4 ]; then return; fi
            header="[INFO]  "; color="\033[37m"
            ;;
        debug)
            if [ "${SPACE_LOG_LEVEL:-4}" -lt 5 ]; then return; fi
            header="[DEBUG] "; color=""
            ;;
        *)
            return
            ;;
    esac
    if [ "${SPACE_LOG_ENABLE_COLORS}" = "1" ] && [ -t 2 ]; then
        printf "${color}%s%s%s\033[0m\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    else
        printf "%s%s%s\n" "${header}" "${_SPACE_NAME}" "${1}" >&2
    fi
}

GET_HOST_STATE()
{
    local _SPACE_NAME="GET_HOST_STATE"

    _PRJ_GET_HOST_STATE "$@"
}

SET_HOST_STATE()
{
    local _SPACE_NAME="SET_HOST_STATE"

    _PRJ_SET_HOST_STATE "$@"
}

GEN_INGRESS_CONFIG()
{
    local _SPACE_NAME="GEN_INGRESS_CONFIG"

    _PRJ_GEN_INGRESS_CONFIG "$@"
}

GET_POD_RELEASE_STATES()
{
    local _SPACE_NAME="GET_POD_RELEASE_STATES"

    local podTriple="${1}"
    shift

    local quite="${1:-false}"
    shift $(($# > 0 ? 1 : 0))

    _PRJ_GET_POD_RELEASE_STATES "${podTriple}" "${quite}"
}

LOGS()
{
    local _SPACE_NAME="LOGS"

    _PRJ_GET_POD_LOGS "$@"
}

SET_POD_RELEASE_STATE()
{
    local _SPACE_NAME="SET_POD_RELEASE_STATE"

    local state="${1}"
    shift

    _PRJ_SET_POD_RELEASE_STATE "${state}" "$@"
}

DELETE_POD()
{
    local _SPACE_NAME="DELETE_POD"

    _PRJ_DELETE_POD "$@"
}

UPDATE_POD_CONFIG()
{
    local _SPACE_NAME="UPDATE_POD_CONFIG"

    local podTriple="${1}"
    shift

    _PRJ_UPDATE_POD_CONFIG "${podTriple}"
}

COMPILE_POD()
{
    local _SPACE_NAME="COMPILE_POD"

    _PRJ_COMPILE_POD "$@"
}

DETACH_POD()
{
    local _SPACE_NAME="DETACH_POD"

    local podTuple="${1}"
    shift

    _PRJ_DETACH_POD "${podTuple}"
}

ATTACH_POD()
{
    local _SPACE_NAME="ATTACH_POD"

    local podTuple="${1}"
    shift

    _PRJ_ATTACH_POD "${podTuple}"
}

LIST_HOSTS_BY_POD()
{
    local _SPACE_NAME="LIST_HOSTS_BY_POD"

    local pod="${1}"
    shift

    _PRJ_LIST_ATTACHEMENTS "${pod}"
}

LIST_PODS()
{
    local _SPACE_NAME="LIST_PODS"

    _PRJ_LIST_PODS
}

LIST_HOSTS()
{
    local _SPACE_NAME="LIST_HOSTS"

    local all="${1:-false}"
    shift $(($# > 0 ? 1 : 0))

    local showState="${1:-false}"
    shift $(($# > 0 ? 1 : 0))

    local filter="1"
    if [ "${all}" = "true" ]; then
        filter="0"
    fi

    _PRJ_LIST_HOSTS "${filter}" "${showState}"
}

HOST_SETUP()
{
    local _SPACE_NAME="HOST_SETUP"

    local host="${1}"
    shift

    _PRJ_HOST_SETUP "${host}"
}

HOST_CREATE_SUPERUSER()
{
    local _SPACE_NAME="HOST_CREATE_SUPERUSER"

    local host="${1}"
    shift

    local keyfile="${1}"
    shift

    _PRJ_HOST_CREATE_SUPERUSER "${host}" "${keyfile}"
}

HOST_DISABLE_ROOT()
{
    local _SPACE_NAME="HOST_DISABLE_ROOT"

    local host="${1}"
    shift

    _PRJ_HOST_DISABLE_ROOT "${host}"
}

HOST_INIT()
{
    local _SPACE_NAME="HOST_INIT"

    local host="${1}"
    shift

    local force="${1:-false}"
    shift $(($# > 0 ? 1 : 0))

    _PRJ_HOST_INIT "${host}" "${force}"
}

HOST_CREATE()
{
    local _SPACE_NAME="HOST_CREATE"

    local host="${1}"
    shift

    local jumpHost="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    local expose="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    local hostHome="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    _PRJ_HOST_CREATE "${host}" "${jumpHost}" "${expose}" "${hostHome}"
}

CLUSTER_IMPORT_POD_CFG()
{
    local _SPACE_NAME="CLUSTER_IMPORT_POD_CFG"

    local pod="${1}"
    shift

    _PRJ_CLUSTER_IMPORT_POD_CFG "${pod}"
}

CLUSTER_STATUS()
{
    local _SPACE_NAME="CLUSTER_STATUS"

    _PRJ_GET_CLUSTER_STATUS
}

CLUSTER_CREATE()
{
    local _SPACE_NAME="CLUSTER_CREATE"

    local clusterName="${1}"
    shift

    _PRJ_CLUSTER_CREATE "${PWD}" "${clusterName}"
}

CLUSTER_SYNC()
{
    local _SPACE_NAME="CLUSTER_SYNC"

    _SYNC_RUN "$@"
}

DAEMON_LOG()
{
    local _SPACE_NAME="DAEMON_LOG"

    _PRJ_GET_DAEMON_LOG "$@"
}

_GETOPTS()
{
    local _SPACE_NAME="_GETOPTS"

    local simpleSwitches="${1}"
    shift

    local richSwitches="${1}"
    shift

    local minPositional="${1:-0}"
    shift

    local maxPositional="${1:-0}"
    shift

    _out_rest=""

    local options=""
    local option=
    for option in ${richSwitches}; do
        options="${options}${option}:"
    done

    local posCount="0"
    while [ "$#" -gt 0 ]; do
        local flag="${1#-}"
        if [ "${flag}" = "${1}" ]; then
            # Non switch
            posCount="$((posCount+1))"
            if [ "${posCount}" -gt "${maxPositional}" ]; then
                PRINT "Too many positional argumets, max ${maxPositional}" "error" 0
                return 1
            fi
            _out_rest="${_out_rest}${_out_rest:+ }${1}"
            shift
            continue
        fi
        local flag2=
        STRING_SUBSTR "${flag}" 0 1 "flag2"
        if STRING_ITEM_INDEXOF "${simpleSwitches}" "${flag2}"; then
            if [ "${#flag}" -gt 1 ]; then
                PRINT "Invalid option: -${flag}" "error" 0
                return 1
            fi
            eval "_out_${flag}=\"true\""
            shift
            continue
        fi

        local OPTIND=1
        getopts ":${options}" "flag"
        case "${flag}" in
            \?)
                PRINT "Unknown option ${1-}" "error" 0
                return 1
                ;;
            :)
                PRINT "Option -${OPTARG-} requires an argument" "error" 0
                return 1
                ;;
            *)
                STRING_ESCAPE "OPTARG"
                eval "_out_${flag}=\"${OPTARG}\""
                ;;
        esac
        shift $((OPTIND-1))
    done

    if [ "${posCount}" -lt "${minPositional}" ]; then
        PRINT "Too few positional argumets, min ${minPositional}" "error" 0
        return 1
    fi
}

LS_POD_RELEASE_STATE()
{
    local _SPACE_NAME="LS_POD_RELEASE_STATE"

    _PRJ_LS_POD_RELEASE_STATE "$@"
}

SET_POD_INGRESS_STATE()
{
    local _SPACE_NAME="SET_POD_INGRESS_STATE"

    local state="${1}"
    shift

    if [ "${state}" = "active" ] || [ "${state}" = "inactive" ]; then
        # All good, fall through
        :
    else
        PRINT "State must be active or inactive" "error" 0
        return 1
    fi

    _PRJ_SET_POD_INGRESS_STATE "${state}" "$@"
}

SIGNAL_POD()
{
    local _SPACE_NAME="SIGNAL_POD"

    local podTriple="${1}"
    shift

    _PRJ_SIGNAL_POD "${podTriple}" "$@"
}

RELEASE()
{
    local _SPACE_NAME="RELEASE"

    _RELEASE "$@"
}

LIST_PODS_BY_HOST()
{
    local _SPACE_NAME="LIST_PODS_BY_HOST"

    local host="${1}"
    shift

    _PRJ_LIST_PODS_BY_HOST "${host}"
}

GET_POD_STATUS()
{
    local _SPACE_NAME="GET_POD_STATUS"

    _PRJ_GET_POD_STATUS "$@"
}

POD_SHELL()
{
    local _SPACE_NAME="POD_SHELL"

    local podTriple="${1}"
    shift

    local container="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    local useBash="${1:-false}"
    shift $(($# > 0 ? 1 : 0))

    _PRJ_POD_SHELL "${podTriple}" "${container}" "${useBash}"
}

HOST_SHELL()
{
    local _SPACE_NAME="HOST_SHELL"

    local host="${1}"
    shift

    local superUser="${1:-false}"
    shift $(($# > 0 ? 1 : 0))

    local useBash="${1:-false}"
    shift $(($# > 0 ? 1 : 0))

    _PRJ_HOST_SHELL "${host}" "${superUser}" "${useBash}"
}

STRING_ITEM_COUNT()
{
    local _SPACE_NAME="STRING_ITEM_COUNT"

    local __s="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        __count=$((__count+1))
    done
    eval "${__outvar}=\"\${__count}\""
}

STRING_ITEM_GET()
{
    local _SPACE_NAME="STRING_ITEM_GET"

    local __s="${1}"
    shift

    local __index="${1}"
    shift

    local __outvar="${1}"
    shift

    local __item=
    local __count=0
    for __item in ${__s}; do
        if [ "${__count}" -eq "${__index}" ]; then
            eval "${__outvar}=\"\${__item}\""
            break
        fi
        __count=$((__count+1))
    done
}

_PRJ_GET_HOST_STATE()
{
    local _SPACE_NAME="_PRJ_GET_HOST_STATE"

    local host="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host does not exist" "error" 0
        return 1
    fi

    local dir="${CLUSTERPATH}/${host}"
    local file="${dir}/host.state"

    local state="active"  # active is the default if no state file exists
    if [ -f "${file}" ]; then
        state="$(cat "${file}")"
    fi

    printf "%s\\n" "${state}"
}

_PRJ_SET_HOST_STATE()
{
    local _SPACE_NAME="_PRJ_SET_HOST_STATE"

    local state="${1}"
    shift

    if [ "${state}" != "active" ] && [ "${state}" != "inactive" ] && [ "${state}" != "disabled" ]; then
        PRINT "Unknown state. Try active/inactive/disabled." "error" 0
        return 1
    fi

    local host="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host does not exist" "error" 0
        return 1
    fi

    local file="${CLUSTERPATH}/${host}/host.state"

    printf "%s\\n" "${state}" >"${file}"
}

_PRJ_GEN_INGRESS_CONFIG()
{
    local _SPACE_NAME="_PRJ_GEN_INGRESS_CONFIG"

    local podTuple="${1:-ingress}"
    shift $(($# > 0 ? 1 : 0))

    local excludeClusterPorts="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTuple}"; then
        return 1
    fi

    if [ -n "${host}" ]; then
        PRINT "Do not provide @host, only pod[:version]" "error" 0
        return 1
    fi

    local podVersion="${version}"
    local ingressPod="${pod}"


    STRING_SUBST "excludeClusterPorts" ',' ' ' 1

    local ingressTplDir="${CLUSTERPATH}/_config/${ingressPod}/_tpl"
    local ingressConfDir="${CLUSTERPATH}/_config/${ingressPod}/conf"

    if [ ! -d "${ingressTplDir}" ]; then
        PRINT "Ingress pod ${ingressPod} has no tpl configs in the cluster. Maybe you should import configs for the ingress pod first?" "error" 0
        return 1
    fi

    # For each host and each running pod release:
    # extract all ingress objects from the pod file,
    # merge and translate into haproxy config format.

    local tmpDir=
    if ! tmpDir="$(_UTIL_GET_TMP_DIR)"; then
        PRINT "Could not create temporary directory." "error" 1
        return 1;
    fi

    PRINT "Using temporary directory: ${tmpDir}" "debug" 0

    local hosts=
    hosts="$(_PRJ_LIST_HOSTS 2)"

    # To keep track of pod:releases we already have generated ingress for.
    # Since it doesn't matter what host a pod is on when we generate ingress we
    # only need to do it once for every specific pod release.
    doneReleases=""

    local newline="
"
    local host=
    for host in ${hosts}; do
        PRINT "Processing pods on host ${host}" "debug" 0

        local pods="$(_PRJ_LIST_PODS_BY_HOST "${host}")"
        local pod=
        for pod in ${pods}; do
            if [ "${pod}" = "${ingressPod}" ]; then
                continue
            fi
            local versions="$(_PRJ_GET_POD_RUNNING_RELEASES "${host}" "${pod}")"
            if [ "${versions}" = "" ]; then
                PRINT "Pod ${pod} on ${host} has no running releases, skipping." "info" 0
                continue
            fi
            STRING_SUBST "versions" "${newline}" ' ' 1
            PRINT "Pod ${pod} on ${host} has running releases: ${versions}" "debug" 0
            local version=
            for version in ${versions}; do
                local podFile="${CLUSTERPATH}/${host}/pods/${pod}/release/${version}/pod"
                if [ ! -f "${podFile}" ]; then
                    PRINT "Pod ${pod} release:${version} executable on ${host} is missing." "error" 0
                    return 1
                fi

                # Check if we already done this pod:release
                if STRING_ITEM_INDEXOF "${doneReleases}" "${pod}:${version}"; then
                    PRINT "Release ${version} already processed, moving on." "info" 0
                    continue
                fi
                doneReleases="${doneReleases} ${pod}:${version}"

                PRINT "Generating ingress for ${pod}:${version} on ${host}" "info" 0

                if ! _PRJ_EXTRACT_INGRESS "${podFile}" "${tmpDir}" "${host}" "${pod}" "${excludeClusterPorts}"; then
                    return 1
                fi
            done
        done
    done

    local haproxyConf=
    if ! haproxyConf="$(_PRJ_GEN_INGRESS_CONFIG2 "${tmpDir}" "${ingressTplDir}")"; then
        PRINT "Could not generate ingress conf. Debug output is in ${tmpDir}." "error" 0
        return 1
    fi

    # Perform variable substitution on conf.
    local variablesToSubst="$(TEXT_EXTRACT_VARIABLES "${haproxyConf}")"

    # First sweep
    # Go over all variable names and for those who are not all CAPS we prefix the variables
    # names with podname and underscore.
    local newline="
"
    local variablesToSubst2=""
    local variablesAll=""
    local values=""
    local varname=
    for varname in ${variablesToSubst}; do
        if ! STRING_IS_ALL "${varname}" "A-Za-z0-9_" || [ "${varname#[_0-9]}" != "${varname}" ]; then
            PRINT "Variable name '${varname}' contains illegal characters. Only [A-Za-z0-9_] are allowed, and cannot begin with underscore or digit." "error" 0
            return 1
        fi
        if STRING_IS_ALL "${varname}" "A-Z0-9_"; then
            # All CAPS, just substitute it with it's value from cluster-vars.env (added later).
            variablesAll="${variablesAll}${variablesAll:+, }${varname}"
        else
            # Not all caps, prefix the variable name with "podname_", as it is defined in cluster-vars.env
            # The actual value substituation will happen in the second sweep.
            values="${values}${values:+${newline}}${varname}=\$\{${ingressPod}_${varname}\}"
            # Save the variable name to subst for the second sweep
            variablesToSubst2="${variablesToSubst2}${variablesToSubst2:+ }${ingressPod}_${varname}"
            variablesAll="${variablesAll}${variablesAll:+ }${ingressPod}_${varname}"
        fi
    done

    PRINT "Variable names extracted from haproxy.conf and which should be defined in cluster-vars.env: ${variablesAll}" "info" 0

    local clusterConfig="${CLUSTERPATH}/cluster-vars.env"
    values="${values}${newline}$(cat "${clusterConfig}")"
    haproxyConf="$(TEXT_VARIABLE_SUBST "${haproxyConf}" "${variablesToSubst}" "${values}")"

    # Second and final sweep
    local values2="$(cat "${clusterConfig}")"
    haproxyConf="$(TEXT_VARIABLE_SUBST "${haproxyConf}" "${variablesToSubst2}" "${values2}")"
    haproxyConf="$(printf "%s\\n" "${haproxyConf}" |TEXT_FILTER)"

    # Save conf in ingress pod cfg, if changed.
    mkdir -p "${ingressConfDir}"
    local haproxyConfPath="${ingressConfDir}/haproxy.cfg"
    # Diff current haproxy.cfg with newley generated one
    if ! (printf "%s\\n" "${haproxyConf}" |diff "${haproxyConfPath}" - >/dev/null 2>&1); then
        # Different
        PRINT "Updating haproxy.cfg in ${ingressConfDir}" "info" 0
        printf "%s\\n" "${haproxyConf}" >"${haproxyConfPath}"
        PRINT "Now you need to run 'snt update-config ${ingressPod}:${podVersion}' and then 'snt sync' to put the updated ingress configuration live" "debug" 0
    else
        PRINT "No changes in ingress to be made." "info" 0
    fi

    rm -rf "${tmpDir}"
}

_PRJ_GET_POD_RELEASE_STATES()
{
    local _SPACE_NAME="_PRJ_GET_POD_RELEASE_STATES"

    local podTriple="${1}"
    shift

    local quite="${1:-false}"
    shift

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTriple}"; then
        return 1
    fi

    local hosts=
    if [ -n "${host}" ]; then
        if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
            PRINT "Host ${host} does not exist." "error" 0
            return 1
        fi

        hosts="${host}";
    else
        hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
    fi
    unset host

    if [ -z "${hosts}" ]; then
        PRINT "Pod is not attached to any host" "warning" 0
        return
    fi

    local podVersion=
    local host=
    for host in ${hosts}; do
        if ! podVersion="$(_PRJ_FIND_POD_VERSION "${pod}" "${version}" "${host}")"; then
            #PRINT "Version ${version} not found on host ${host}. Skipping." "info" 0
            continue
        fi

        local state=
        if ! state="$(_PRJ_GET_POD_RELEASE_STATE "${host}" "${pod}" "${podVersion}")"; then
            #PRINT "Version ${podVersion} state not found on host ${host}. Skipping." "warning" 0
            continue
        fi

        if [ "${quite}" = "true" ]; then
            printf "%s\\n" "${state}"
        else
            printf "%s:%s@%s %s\\n" "${pod}" "${podVersion}" "${host}" "${state}"
        fi
    done
}

_PRJ_GET_POD_LOGS()
{
    local _SPACE_NAME="_PRJ_GET_POD_LOGS"

    local timestamp="${1:-0}"
    shift

    local limit="${1:-0}"
    shift

    local streams="${1:-stdout,stderr}"
    shift

    if ! STRING_IS_NUMBER "${timestamp}"; then
        PRINT "timeout must be positive number (seconds since epoch)" "error" 0
        return 1
    fi

    if ! STRING_IS_NUMBER "${limit}" 1; then
        PRINT "limit must be a number" "error" 0
        return 1
    fi

    if [ "${streams}" = "stdout" ] || [ "${streams}" = "stderr" ] || [ "${streams}" = "stdout,stderr" ] || [ "${streams}" = "stderr,stdout" ]; then
        # All good, fall through
        :
    else
        PRINT "streams must be: stdout, stderr or \"stdout,stderr\"" "error" 0
        return 1
    fi

    local podTriple="${1}"
    shift

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTriple}"; then
        return 1
    fi

    local hosts=
    if [ -n "${host}" ]; then
        if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
            PRINT "Host ${host} does not exist" "error" 0
            return 1
        fi

        hosts="${host}"
    else
        hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
    fi
    unset host

    if [ -z "${hosts}" ]; then
        PRINT "Pod is not attached to any host." "warning" 0
        return
    fi

    local podVersion=
    local host=
    for host in ${hosts}; do
        if ! podVersion="$(_PRJ_FIND_POD_VERSION "${pod}" "${version}" "${host}")"; then
            continue
        fi

        _PRJ_GET_POD_LOGS2 "${host}" "${pod}" "${podVersion}" "${timestamp}" "${limit}" "${streams}"
    done
}

_PRJ_SET_POD_RELEASE_STATE()
{
    local _SPACE_NAME="_PRJ_SET_POD_RELEASE_STATE"

    local state="${1}"
    shift

    if ! _PRJ_ENUM_STATE "${state}"; then
        PRINT "Given state is not a valid state: ${state}. Valid states are: running, stopped and removed" "error" 0
        return 1
    fi

    local podTriple=
    for podTriple in "$@"; do
        local pod=
        local version=
        local host=
        if ! _PRJ_SPLIT_POD_TRIPLE "${podTriple}"; then
            return 1
        fi

        local hosts=
        if [ -n "${host}" ]; then
            if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
                PRINT "Host ${host} does not exist." "error" 0
                return 1
            fi

            hosts="${host}"
        else
            hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
        fi
        unset host

        if [ -z "${hosts}" ]; then
            PRINT "Pod '${pod}' is not attached to any host." "warning" 0
            continue
        fi

        local podVersion=
        local host=
        for host in ${hosts}; do
            if ! podVersion="$(_PRJ_FIND_POD_VERSION "${pod}" "${version}" "${host}")"; then
                PRINT "Version ${version} not found on host ${host}. Skipping." "info" 0
                continue
            fi

            local stateFile="pod.state"
            local targetPodDir="${CLUSTERPATH}/${host}/pods/${pod}/release/${podVersion}"
            local targetPodStateFile="${targetPodDir}/${stateFile}"

            if [ ! -d "${targetPodDir}" ]; then
                PRINT "Pod ${pod}:${podVersion} not found on host ${host}. Skipping." "warning" 0
                continue
            fi

            PRINT "Set state of release ${podVersion} on host ${host} to ${state}." "info" 0

            printf "%s\\n" "${state}" >"${targetPodStateFile}"

            _PRJ_LOG_P "${host}" "${pod}" "SET_POD_RELEASE_STATE release:${podVersion}=${state}"
        done
    done
}

_PRJ_DELETE_POD()
{
    local _SPACE_NAME="_PRJ_DELETE_POD"

    local podTriple=
    for podTriple in "$@"; do
        local pod=
        local version=
        local host=
        if ! _PRJ_SPLIT_POD_TRIPLE "${podTriple}"; then
            return 1
        fi

        local hosts=
        if [ -n "${host}" ]; then
            if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
                PRINT "Host ${host} does not exist." "error" 0
                return 1
            fi

            hosts="${host}"
        else
            hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
        fi
        unset host

        if [ -z "${hosts}" ]; then
            PRINT "Pod '${pod}' is not attached to any host." "warning" 0
            continue
        fi

        local podVersion=
        local host=
        for host in ${hosts}; do
            if ! podVersion="$(_PRJ_FIND_POD_VERSION "${pod}" "${version}" "${host}")"; then
                PRINT "Version ${version} not found on host ${host}. Skipping." "info" 0
                continue
            fi

            local stateFile="pod.state"
            local targetPodDir="${CLUSTERPATH}/${host}/pods/${pod}/release/${podVersion}"
            local targetPodDir2="${CLUSTERPATH}/${host}/pods/${pod}/release/.${podVersion}.$(date +%s)"
            local targetPodStateFile="${targetPodDir}/${stateFile}"

            if [ ! -f "${targetPodStateFile}" ]; then
                PRINT "Pod ${pod}:${podVersion} not found on host ${host}. Skipping." "warning" 0
                continue
            fi

            local state="$(cat "${targetPodStateFile}")"
            if [ "${state}" != "removed" ]; then
                PRINT "Pod ${pod}:${podVersion} on host ${host} is not in the 'removed' state. Skipping." "warning" 0
                continue
            fi

            mv "${targetPodDir}" "${targetPodDir2}"

            PRINT "Delete release ${podVersion} on host ${host}" "info" 0

            _PRJ_LOG_P "${host}" "${pod}" "DELETE_RELEASE ${podVersion}"
        done
    done
}

_PRJ_UPDATE_POD_CONFIG()
{
    local _SPACE_NAME="_PRJ_UPDATE_POD_CONFIG"

    local podTriple="${1}"
    shift

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTriple}"; then
        return 1
    fi

    if [ ! -d "${CLUSTERPATH}/_config/${pod}" ]; then
        PRINT "_config/${pod} does not exist in cluster, maybe import them first?" "error" 0
        return 1
    fi

    local hosts=
    if [ -n "${host}" ]; then
        if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
            PRINT "Host ${host} does not exist." "error" 0
            return 1
        fi

        hosts="${host}"
    else
        hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
    fi
    unset host

    if [ -z "${hosts}" ]; then
        PRINT "Pod ${pod} is not attached to any host." "warning" 0
        return 0
    fi

    local configCommit=
    if ! configCommit="$(_UTIL_GET_TAG_DIR "${CLUSTERPATH}/_config/${pod}")"; then
        return 1
    fi

    local podVersion=
    local host=
    for host in ${hosts}; do
        if ! podVersion="$(_PRJ_FIND_POD_VERSION "${pod}" "${version}" "${host}")"; then
            #PRINT "Version ${version} not found on host ${host}. Skipping." "info" 0
            continue
        fi
        if [ -d "${CLUSTERPATH}/${host}/pods/${pod}/release/${podVersion}" ]; then
            PRINT "Copy ${pod} configs from cluster into release ${podVersion} on host ${host}." "info" 0
            rm -rf "${CLUSTERPATH}/${host}/pods/${pod}/release/${podVersion}/config"
            if ! _PRJ_COPY_POD_CONFIGS "${CLUSTERPATH}" "${host}" "${pod}" "${podVersion}"; then
                return 1
            fi
            if ! _PRJ_CHKSUM_POD_CONFIGS "${CLUSTERPATH}" "${host}" "${pod}" "${podVersion}"; then
                return 1
            fi
        else
            PRINT "Release ${podVersion} does not exist on host ${host}, skipping." "info" 0
            continue
        fi

        _PRJ_LOG_P "${host}" "${pod}" "UPDATE_CONFIG release:${podVersion} cfg:${configCommit}"
    done
}

_PRJ_COMPILE_POD()
{
    local _SPACE_NAME="_PRJ_COMPILE_POD"

    local podTuple="${1}"
    shift

    local verbose="${1:-false}"
    shift $(($# > 0 ? 1 : 0))

    local expectedPodVersion="${1:-}"
    shift $(($# > 0 ? 1 : 0))

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTuple}"; then
        return 1
    fi


    local attachedHosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"

    if [ -z "${attachedHosts}" ]; then
        PRINT "Pod '${pod}' is not attached to this cluster." "error" 0
        return 1
    fi

    local clusterConfig="${CLUSTERPATH}/cluster-vars.env"
    if ! [ -f "${clusterConfig}" ]; then
        PRINT "Pod cluster config ${clusterConfig} not found." "error" 0
        return 1
    fi

    local hosts=
    if [ -n "${host}" ]; then
        if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
            PRINT "Host ${host} does not exist." "error" 0
            return 1
        fi
        if ! STRING_ITEM_INDEXOF "${attachedHosts}" "${host}"; then
            PRINT "Pod '${pod}' is not attached to host '${host}'." "error" 0
            return 1
        fi
        hosts="${host}"
    else
        hosts="${attachedHosts}"
    fi
    unset host

    if [ -z "${hosts}" ]; then
        PRINT "Pod ${pod} is not attached to any host." "warning" 0
        return 0
    fi

    local podSpec="$(FILE_REALPATH "${PODPATH}/${pod}/pod.yaml")"

    local podCommit=
    if ! podCommit="$(_UTIL_GET_TAG_FILE "${podSpec}")"; then
        return 1
    fi

    local clusterCommit=
    if ! clusterCommit="$(_UTIL_GET_TAG_FILE "${clusterConfig}")"; then
        return 1
    fi

    local configCommit="<none>"
    if [ ! -d "${CLUSTERPATH}/_config/${pod}" ]; then
        PRINT "No configs exist in the cluster for this pod" "info" 0
    else
        if ! configCommit="$(_UTIL_GET_TAG_DIR "${CLUSTERPATH}/_config/${pod}")"; then
            return 1
        fi
    fi

    if ! command -v podc >/dev/null 2>/dev/null; then
        PRINT "podc not available on path, cannot compile pod." "error" 0
        return 1
    fi

    PRINT "Compiling pod ${pod}" "info" 0

    ## Now everything is setup for us to compile the pod onto each host it is attached to.

    local status=0  # Status flag checked after the for-loop.
    local podsCompiled=""  # Keep track of all pods compiled so we can remove them if we encounter an error.
    local host=
    for host in ${hosts}; do
        # Perform variable substitution
        ## 1. Extract variables used in pod.yaml file
        ## 2. Inspect those to see if any are ${HOSTPORTAUTOxyz}, then for each 'xyz' we find a free host port on the host to assign that variable.
        ## 3. Prefix any variables naames in pod.yaml with "podname_".
        ## 4. Run first sweep of substitution.
        ## 5. Load cluster variables from cluster-vars.env
        ## 6. Run second sweep of variable substituation on pod.yaml

        local text="$(cat "${podSpec}")"
        local variablesToSubst="$(TEXT_EXTRACT_VARIABLES "${text}")"
        local newline="
"

        # For each ${HOSTPORTAUTOxyz} we find free host ports and substitute that.
        local variablesAll=""       # For show, all variables read from cluster-vars.env
        local variablesToSubst2=""  # Use this to save variable names for the second sweep of substitutions.
        local values=""             # Values to substitute in first sweep
        local newHostPorts=""       # To keep track of already assigned host ports
        local newClusterPorts=""   # To keep track of already assigned cluster ports
        local varname=
        for varname in ${variablesToSubst}; do
            # Do sanity check on the variable name extracted.
            if ! STRING_IS_ALL "${varname}" "A-Za-z0-9_" || [ "${varname#[_0-9]}" != "${varname}" ]; then
                PRINT "Variable name '${varname}' contains illegal characters. Only [A-Za-z0-9_] are allowed, and cannot begin with underscore or digit." "error" 0
                status=1
                break 2
            fi
            if [ "${varname#HOSTPORTAUTO}" != "${varname}" ]; then
                # This is an auto host port assignment,
                # we need to find a free port and assign the variable.
                local newport=
                if ! newport="$(_PRJ_GET_FREE_HOSTPORT "${host}" "${newHostPorts}")"; then
                    PRINT "Could not acquire a free host port on the host ${host}." "error" 0
                    status=1
                    break 2
                fi
                newHostPorts="${newHostPorts} ${newport}"
                values="${values}${values:+${newline}}${varname}=${newport}"
            elif [ "${varname#CLUSTERPORTAUTO}" != "${varname}" ]; then
                # This is an auto cluster port assignment,
                # we need to find a free port and assign the variable.
                local newport=
                if ! newport="$(_PRJ_GET_FREE_CLUSTERPORT "${newHostPorts}")"; then
                    PRINT "Could not acquire a free cluster port." "error" 0
                    status=1
                    break 2
                fi
                newHostPorts="${newHostPorts} ${newport}"
                values="${values}${values:+${newline}}${varname}=${newport}"
            else
                # This is user defined variable, check if it is global or pod specific.
                # Global variables are shared between pods and are all CAPS.
                # Variables which are not all caps are expected to have the pod name as a prefix as defined in cluster-vars.env, because they are pod specific.
                if STRING_IS_ALL "${varname}" "A-Z0-9_"; then
                    # All CAPS, just substitute it with it's value from cluster-vars.env, added later.
                    variablesAll="${variablesAll}${variablesAll:+, }${varname}"
                else
                    # Not all caps, prefix the variable name defined in pod.yaml with "podname_", as it is defined in cluster-vars.env
                    # The actual value substituation will happen in the second sweep.
                    values="${values}${values:+${newline}}${varname}=\$\{${pod}_${varname}\}"
                    # Save the variable name to subst for the second sweep
                    variablesToSubst2="${variablesToSubst2}${variablesToSubst2:+ }${pod}_${varname}"
                    variablesAll="${variablesAll}${variablesAll:+ }${pod}_${varname}"
                fi
            fi
        done

        if [ -n "${newClusterPorts}" ]; then
            PRINT "Cluster ports auto generated:${newClusterPorts}" "info" 0
        fi

        if [ -n "${newClusterPorts}" ]; then
            PRINT "Host ports auto generated:${newClusterPorts}" "info" 0
        fi

        PRINT "Variable names extracted from pod.yaml and which should be defined in cluster-vars.env: ${variablesAll}" "info" 0
        # Check so that all variables are defined in cluster-vars.env, if not issue a warning.
        local varname=
        for varname in ${variablesAll}; do
            if ! grep -q -m 1 "^${varname}=" "${clusterConfig}"; then
                PRINT "Pod variable ${varname} is not defined in cluster-vars.env" "warning" 0
            fi
        done

        # For each variable identified in pod.yaml, iterate over it and substitute it for its value
        # Do a first sweep, substituting auto host ports, substituting CAPS global variable for values and adding prefix to all other variables.
        values="${values}${newline}$(cat "${clusterConfig}")"
        text="$(TEXT_VARIABLE_SUBST "${text}" "${variablesToSubst}" "${values}")"

        # Second sweep of substitutions
        local values2="$(cat "${clusterConfig}")"
        text="$(TEXT_VARIABLE_SUBST "${text}" "${variablesToSubst2}" "${values2}")"
        text="$(printf "%s\\n" "${text}" |TEXT_FILTER)"

        local podVersion="$(printf "%s\\n" "${text}" |grep -o "^podVersion:[ ]*['\"]\?\([0-9]\+\.[0-9]\+\.[0-9]\+\(-[-.a-z0-9]\+\)\?\)")"
        podVersion="${podVersion#*:}"
        STRING_SUBST "podVersion" "'" "" 1
        STRING_SUBST "podVersion" '"' "" 1
        STRING_TRIM "podVersion"

        if [ -z "${podVersion}" ]; then
            PRINT "podVersion is missing. Must be on semver format (major.minor.patch[-tag])." "error" 0
            return 1
        fi

        if [ -n "${expectedPodVersion}" ] && [ "${expectedPodVersion}" != "${podVersion}" ]; then
            PRINT "Pod source version ${podVersion} does not match the expected version ${expectedPodVersion}" "error" 0
            return 1
        fi

        local targetPodDir="${CLUSTERPATH}/${host}/pods/${pod}/release/${podVersion}"

        if [ -d "${targetPodDir}" ]; then
            PRINT "Pod ${pod} version ${podVersion} already exists on host ${host}. Skipping." "info" 0
            continue
        fi

        if ! mkdir -p "${targetPodDir}"; then
            PRINT "Could not create directory: ${targetPodDir}" "error" 0
            status=1
            break
        fi

        podsCompiled="${podsCompiled} ${targetPodDir}"

        PRINT "Pod ${pod} version ${podVersion} compiling for host ${host}." "info" 0

        local tmpPodSpec="${targetPodDir}/.pod.yaml"
        local targetPodSpec="${targetPodDir}/pod"
        PRINT "Parse yaml for pod ${pod} to host ${host} as ${tmpPodSpec}." "debug" 0

        # Save the preprocessed yaml.
        printf "%s\\n" "${text}" >"${tmpPodSpec}"

        # Copy configs into release
        if [ -d "${CLUSTERPATH}/_config/${pod}" ]; then
            PRINT "Copy configs from cluster into pod release." "info" 0
            if ! _PRJ_COPY_POD_CONFIGS "${CLUSTERPATH}" "${host}" "${pod}" "${podVersion}"; then
                status=1
                break
            fi
        fi

        if ! SPACE_LOG_LEVEL="${SPACE_LOG_LEVEL}" podc "${pod}" -f "${tmpPodSpec}" -o "${targetPodSpec}" -d "${podSpec%/*}" -p false; then
            status=1
            break
        fi

        # Checksum configs, we do this after compiling since comilation can add to configs.
        if [ -d "${CLUSTERPATH}/_config/${pod}" ]; then
            PRINT "Checksum configs in release." "debug" 0
            if ! _PRJ_CHKSUM_POD_CONFIGS "${CLUSTERPATH}" "${host}" "${pod}" "${podVersion}"; then
                status=1
                break
            fi
        fi

        # Set state as running.
        local targetpodstate="${targetPodDir}/pod.state"
        printf "%s\\n" "running" >"${targetpodstate}"

        _PRJ_LOG_P "${host}" "${pod}" "COMPILE_POD release:${podVersion} pod.yaml:${podCommit} cluster-vars.env:${clusterCommit} cfg:${configCommit}"
    done

    if [ "${status}" -gt 0 ] && [ -n "${podsCompiled}" ]; then
        PRINT "Removing compiled pods" "info" 0
        local dir=
        for dir in ${podsCompiled}; do
            rm -rf "${dir}"
        done
        return 1
    fi

    if [ -z "${podsCompiled}" ]; then
        PRINT "Pod not compiled." "error" 0
    fi

    if [ "${verbose}" = "true" ] && [ -n "${podsCompiled}" ]; then
        printf "%s\\n" "${podVersion}"
    fi
}

_PRJ_DETACH_POD()
{
    local _SPACE_NAME="_PRJ_DETACH_POD"

    local podTuple="${1}"

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTuple}"; then
        return 1
    fi

    local attachedHosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"

    if [ -z "${attachedHosts}" ]; then
        PRINT "Pod '${pod}' is not attached to this cluster." "error" 0
        return 1
    fi

    local hosts=
    if [ -n "${host}" ]; then
        if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
            PRINT "Host ${host} does not exist." "error" 0
            return 1
        fi
        if ! STRING_ITEM_INDEXOF "${attachedHosts}" "${host}"; then
            PRINT "Pod '${pod}' is not attached to host '${host}'." "error" 0
            return 1
        fi
        hosts="${host}"
    else
        hosts="${attachedHosts}"
    fi
    unset host

    local host=
    for host in ${hosts}; do
        _PRJ_LOG_P "${host}" "${pod}" "DETACHED"
        local ts="$(date +%s)"
        if ! mv "${CLUSTERPATH}/${host}/pods/${pod}" "${CLUSTERPATH}/${host}/pods/.${pod}.${ts}"; then
            PRINT "Unexpected disk failure when detaching pod." "error" 0
            return 1
        fi

        PRINT "Pod '${pod}' detached from '${host}'" "info" 0
    done

    # Check if this was the last pod on the hosts, if so suggest to remove any pod configs in the cluster.
    local hosts=
    hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
    if [ -z "${hosts}" ]; then
        if [ -d "${CLUSTERPATH}/_config/${pod}" ]; then
            PRINT "There are no more pods of this sort left in this cluster, but there are configs still. You can remove those configs if you want to." "info" 0
        fi
    fi
}

_PRJ_ATTACH_POD()
{
    local _SPACE_NAME="_PRJ_ATTACH_POD"

    local podTuple="${1}"

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTuple}"; then
        return 1
    fi

    if ! STRING_IS_ALL "${pod}" "a-z0-9_" || [ "${pod#[_0-9]}" != "${pod}" ]; then
        PRINT "Invalid pod name. Only 0-9, lowercase a-z and underscore is allowed. Name cannot begin with underscore or digit" "error" 0
        return 1
    fi

    if [ -z "${host}" ]; then
        PRINT "A host must be provided as podname@host" "error" 0
        return 1
    fi

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does not exist." "error" 0
        return 1
    fi

    if _PRJ_IS_POD_ATTACHED "${CLUSTERPATH}" "${host}" "${pod}"; then
        PRINT "Pod ${pod} already exists on host ${host}." "error" 0
        return 1
    fi

    local podSpec="$(FILE_REALPATH "${PODPATH}/${pod}/pod.yaml")"
    if [ ! -f "${podSpec}" ]; then
        PRINT "pod.yaml does not exist as: ${podSpec}" "error" 0
        return 1
    fi
    local text="$(cat "${podSpec}")"
    local variablesToSubst="$(TEXT_EXTRACT_VARIABLES "${text}")"
    local varname=
    for varname in ${variablesToSubst}; do
        if STRING_IS_ALL "${varname}" "A-Z0-9_"; then
            # ALL CAPS global variables
            # Don't show {HOST,CLUSTER}PORTAUTOxyz variable names
            if [ "${varname#HOSTPORTAUTO}" = "${varname}" ] && [ "${varname#CLUSTERPORTAUTO}" = "${varname}" ]; then
                PRINT "Variable ${varname} is defined in pod.yaml, you might want to defined it in the cluster-vars.env file" "info" 0
            fi
        else
            # Prefixed variable names.
            PRINT "Variable ${pod}_${varname} is defined in pod.yaml, you might want to defined it in the cluster-vars.env file" "info" 0
        fi
    done

    local podConfigDir="$(FILE_REALPATH "${PODPATH}/${pod}/config")"

    if ! mkdir -p "${CLUSTERPATH}/${host}/pods/${pod}"; then
        PRINT "Could not create directory." "error" 0
        return 1
    fi

    _PRJ_LOG_P "${host}" "${pod}" "ATTACHED"

    PRINT "Pod is now attached" "info" 0

    # Check if this was the first pod on the hosts, if so suggest to also add any pod configs into the cluster.
    local hosts=
    hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
    if [ "${hosts}" = "${host}" ]; then
        if [ ! -d "${CLUSTERPATH}/_config/${pod}" ] && [ -d "${podConfigDir}" ]; then
            PRINT "This was the first attachement of this pod to this cluster, you might want to import the pod configs into the cluster" "info" 0
        fi
    fi
}

_PRJ_LIST_ATTACHEMENTS()
{
    local _SPACE_NAME="_PRJ_LIST_ATTACHEMENTS"

    local pod="${1}"
    shift

    if [ -z "${pod}" ]; then
        return 1
    fi

    (cd "${CLUSTERPATH}" && find . -maxdepth 4 -mindepth 4 -regex "^./[^.][^/]*/pods/${pod}/log\.txt\$" |cut -d/ -f2)
}

_PRJ_LIST_PODS()
{
    local _SPACE_NAME="_PRJ_LIST_PODS"
    (cd "${PODPATH}" && find . -maxdepth 2 -mindepth 2 -type f -name pod.yaml |cut -d/ -f2)
}

_PRJ_LIST_HOSTS()
{
    local _SPACE_NAME="_PRJ_LIST_HOSTS"

    local filter="${1:-1}"
    shift

    local showState="${1:-false}"
    shift $(($# > 0 ? 1 : 0))

    local hosts=
    hosts="$(cd "${CLUSTERPATH}" && find . -maxdepth 2 -mindepth 2 -type f -regex "^./[^.][^/]*/host\.env\$" |cut -d/ -f2)"

    local host=
    for host in ${hosts}; do
        local state=$(_PRJ_GET_HOST_STATE "${host}")
        if [ "${filter}" = "1" ]; then
            if [ "${state}" = "disabled" ]; then
                continue
            fi
        elif [ "${filter}" = "2" ]; then
            if [ "${state}" != "active" ]; then
                continue
            fi
        fi
        if [ "${showState}" = "true" ]; then
            printf "%s %s\\n" "${host}" "${state}"
        else
            printf "%s\\n" "${host}"
        fi
    done
}

_PRJ_HOST_SETUP()
{
    local _SPACE_NAME="_PRJ_HOST_SETUP"

    local host="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does not exist." "error" 0
        return 1
    fi

    # Load host env file and create a new temporary one
    hostEnv="${CLUSTERPATH}/${host}/host.env"
    hostEnv2="${CLUSTERPATH}/${host}/host-superuser.env"
    if [ ! -f "${hostEnv}" ]; then
        PRINT "${hostEnv} file does not exist." "error" 0
        return 1
    fi

    local USER=
    local KEYFILE=
    local SUPERUSER=
    local SUPERKEYFILE=
    local HOST=
    local PORT=
    local JUMPHOST=
    local EXPOSE=
    local INTERNAL=

    local value=
    local varname=
    for varname in USER KEYFILE SUPERUSER SUPERKEYFILE HOST PORT JUMPHOST EXPOSE INTERNAL; do
        value="$(grep -m 1 "^${varname}=" "${hostEnv}")"
        value="${value#*${varname}=}"
        STRING_TRIM "value"
        eval "${varname}=\"\${value}\""
    done

    if [ -z "${USER}" ]; then
        PRINT "USER not defined in host.env file" "error" 0
        return 1
    fi

    if [ -z "${KEYFILE}" ]; then
        PRINT "KEYFILE not defined in host.env file" "error" 0
        return 1
    fi

    if [ -z "${SUPERUSER}" ]; then
        PRINT "SUPERUSER not defined in host.env file" "error" 0
        return 1
    fi

    if [ -z "${SUPERKEYFILE}" ]; then
        PRINT "SUPERKEYFILE not defined in host.env file" "error" 0
        return 1
    fi

    if [ -z "${INTERNAL}" ]; then
        # TODO: not sure this is the correct way of setting the internal networks
        INTERNAL="192.168.0.0/16 10.0.0.0/8 172.16.0.0/11"
        PRINT "INTERNAL not defined in host.env file. Setting default: ${INTERNAL}" "warning" 0
    fi

    local port=
    for port in ${EXPOSE}; do
        case "${port}" in
            (*[!0-9]*)
                PRINT "Invalid EXPOSE port provided: ${port}" "error" 0
                return 1
                ;;
            *)
                ;;
        esac
    done

    # Check internal networking.
    # If HOST is an internal IP address, then internal network MUST be correctly setup otherwise the host will
    # become unreachable from the jumphost.
    if [ "${HOST#192.168}" != "${HOST}" ]; then
        if ! STRING_ITEM_INDEXOF "${INTERNAL}" "192.168.0.0/16"; then
            PRINT "The INTERNAL networks setting does not match the HOST IP, this will likely make local networking not work and hosts becoming unmanagable. Please set INTERNAL value in host.env to reflect the private IP network." "error" 0
            return 1
        fi
    fi
    if [ "${HOST#172.16}" != "${HOST}" ]; then
        if ! STRING_ITEM_INDEXOF "${INTERNAL}" "172.16.0.0/11"; then
            PRINT "The INTERNAL networks setting does not match the HOST IP, this will likely make local networking not work and hosts becoming unmanagable. Please set INTERNAL value in host.env to reflect the private IP network." "error" 0
            return 1
        fi
    fi
    if [ "${HOST#10.}" != "${HOST}" ]; then
        if ! STRING_ITEM_INDEXOF "${INTERNAL}" "10.0.0.0/8"; then
            PRINT "The INTERNAL networks setting does not match the HOST IP, this will likely make local networking not work and hosts becoming unmanagable. Please set INTERNAL value in host.env to reflect the private IP network." "error" 0
            return 1
        fi
    fi

    if [ -z "${JUMPHOST}" ] && ! STRING_ITEM_INDEXOF "${EXPOSE}" "22"; then
        PRINT "Port 22 not set to be exposed on this host which does not use a JUMPHOST, meaning it will not be accessible at all. Automatically adding port 22 to the exposed ports list." "warning" 0
        EXPOSE="${EXPOSE}${EXPOSE:+ }22"
    fi

    KEYFILE="$(cd "${CLUSTERPATH}/${host}" && FILE_REALPATH "${KEYFILE}")"

    # If user keyfile does not exist, we create it.
    if [ ! -f "${KEYFILE}" ]; then
        PRINT "Create user keyfile: ${KEYFILE}" "info" 0
        if ! SSH_KEYGEN "${KEYFILE}"; then
            PRINT "Could not genereate keyfile" "error" 0
            return 1
        fi
    fi

    local pubKey="${KEYFILE}.pub"
    if [ ! -f "${KEYFILE}" ]; then
        PRINT "Could not find ${pubKey}" "error" 0
        return 1
    fi

    printf "%s\\n" "# Auto generated host.env file to be used with the Space ssh module.
# You can enter this host as USER by running \"space -m ssh /ssh/ -e SSHHOSTFILE=host-superuser.env\".

HOSTHOME=/
HOST=${HOST}
USER=${SUPERUSER}
KEYFILE=${SUPERKEYFILE}
PORT=${PORT}
JUMPHOST=${JUMPHOST}" >"${hostEnv2}"

    local status=
    cat "${pubKey}" |_REMOTE_EXEC "${host}:${hostEnv2}" "setup_host" "${USER}" "${EXPOSE}" "${INTERNAL}"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        return 0
    fi

    PRINT "Could not install setup host" "error" 0

    # Failed
    return "${status}"
}

_PRJ_HOST_CREATE_SUPERUSER()
{
    local _SPACE_NAME="_PRJ_HOST_CREATE_SUPERUSER"

    local host="${1}"
    shift

    local keyfile="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does not exist." "error" 0
        return 1
    fi

    # Load host env file and create a new temporary one
    hostEnv="${CLUSTERPATH}/${host}/host.env"
    hostEnv2="${CLUSTERPATH}/${host}/.host-root.env"
    if [ ! -f "${hostEnv}" ]; then
        PRINT "${hostEnv} file does not exist." "error" 0
        return 1
    fi

    local SUPERUSER=
    local SUPERKEYFILE=
    local HOST=
    local PORT=
    local JUMPHOST=

    local value=
    local varname=
    for varname in SUPERUSER SUPERKEYFILE HOST PORT JUMPHOST; do
        value="$(grep -m 1 "^${varname}=" "${hostEnv}")"
        value="${value#*${varname}=}"
        STRING_TRIM "value"
        eval "${varname}=\"\${value}\""
    done

    if [ -z "${SUPERUSER}" ]; then
        PRINT "SUPERUSER not defined in host.env file" "error" 0
        return 1
    fi

    if [ -z "${SUPERKEYFILE}" ]; then
        PRINT "SUPERKEYFILE not defined in host.env file" "error" 0
        return 1
    fi

    SUPERKEYFILE="$(cd "${CLUSTERPATH}/${host}" && FILE_REALPATH "${SUPERKEYFILE}")"

    # If keyfile does not exist, we create it.
    if [ ! -f "${SUPERKEYFILE}" ]; then
        PRINT "Create super user keyfile: ${SUPERKEYFILE}" "info" 0
        if ! SSH_KEYGEN "${SUPERKEYFILE}"; then
            PRINT "Could not genereate keyfile" "error" 0
            return 1
        fi
    fi

    local pubKey="${SUPERKEYFILE}.pub"
    if [ ! -f "${SUPERKEYFILE}" ]; then
        PRINT "Could not find ${pubKey} file" "error" 0
        return 1
    fi

    # Create the temporary host.env file
    printf "%s\\n" "HOSTHOME=/
HOST=${HOST}
USER=root
KEYFILE=${keyfile}
PORT=${PORT}
JUMPHOST=${JUMPHOST}" >"${hostEnv2}"

    local status=
    cat "${pubKey}" |_REMOTE_EXEC "${host}:${hostEnv2}" "create_superuser" "${SUPERUSER}"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        rm "${hostEnv2}"
        return 0
    fi
    rm "${hostEnv2}"

    PRINT "Could not create super user." "error" 0

    # Failed
    return "${status}"
}

_PRJ_HOST_DISABLE_ROOT()
{
    local _SPACE_NAME="_PRJ_HOST_DISABLE_ROOT"

    local host="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does not exist." "error" 0
        return 1
    fi

    # Load host env file and create a new temporary one
    hostEnv="${CLUSTERPATH}/${host}/host.env"
    hostEnv2="${CLUSTERPATH}/${host}/.host-superuser.env"
    if [ ! -f "${hostEnv}" ]; then
        PRINT "${hostEnv} file does not exist." "error" 0
        return 1
    fi

    local SUPERUSER=
    local SUPERKEYFILE=
    local HOST=
    local PORT=
    local JUMPHOST=

    local value=
    local varname=
    for varname in SUPERUSER SUPERKEYFILE HOST PORT JUMPHOST; do
        value="$(grep -m 1 "^${varname}=" "${hostEnv}")"
        value="${value#*${varname}=}"
        STRING_TRIM "value"
        eval "${varname}=\"\${value}\""
    done

    if [ -z "${SUPERUSER}" ]; then
        PRINT "SUPERUSER not defined in host.env file" "error" 0
        return 1
    fi

    if [ -z "${SUPERKEYFILE}" ]; then
        PRINT "SUPERKEYFILE not defined in host.env file" "error" 0
        return 1
    fi

    SUPERKEYFILE="$(cd "${CLUSTERPATH}/${host}" && FILE_REALPATH "${SUPERKEYFILE}")"

    if [ ! -f "${SUPERKEYFILE}" ]; then
        PRINT "Super user keyfile is missing: ${SUPERKEYFILE}" "info" 0
        return 1
    fi

    # Create the temporary host.env file
    printf "%s\\n" "HOSTHOME=/
HOST=${HOST}
USER=${SUPERUSER}
KEYFILE=${SUPERKEYFILE}
PORT=${PORT}
JUMPHOST=${JUMPHOST}" >"${hostEnv2}"

    local status=
    _REMOTE_EXEC "${host}:${hostEnv2}" "disable_root"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        rm "${hostEnv2}"
        return 0
    fi
    rm "${hostEnv2}"

    PRINT "Could not disable root." "error" 0

    # Failed
    return "${status}"
}

_PRJ_HOST_INIT()
{
    local _SPACE_NAME="_PRJ_HOST_INIT"

    local host="${1}"
    shift

    local force="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does not exist." "error" 0
        return 1
    fi

    local clusterID=

    if ! clusterID="$(_PRJ_GET_CLUSTER_ID)"; then
        PRINT "Cannot get the ID for this cluster project." "error" 0
        return 1
    fi

    local status=
    _REMOTE_EXEC "${host}" "init_host" "${clusterID}" "${force}"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        return 0
    elif [ "${status}" -eq 2 ]; then
        PRINT "Host already initiated with other cluster ID." "error" 0
        return 2
    fi

    PRINT "Could not init host to cluster." "error" 0

    # Failed
    return "${status}"
}

_PRJ_HOST_CREATE()
{
    local _SPACE_NAME="_PRJ_HOST_CREATE"

    local host="${1}"
    shift

    local jumphost="${1}"
    shift

    local expose="${1}"
    shift

    local hostHome="${1:-cluster-host}"
    shift

    if _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does already exist." "error" 0
        return 1
    fi

    local dir="${CLUSTERPATH}/${host}"
    if [ -d "${dir}" ]; then
        PRINT "Host dir does already exist." "error" 0
        return 1
    fi

    STRING_SUBST "expose" ',' ' ' 1

    local port=
    for port in ${expose}; do
        case "${port}" in
            (*[!0-9]*)
                PRINT "Invalid port provided: ${port}" "error" 0
                return 1
                ;;
            *)
                ;;
        esac
    done

    STRING_TRIM "jumphost"

    if [ -z "${jumphost}" ] && ! STRING_ITEM_INDEXOF "${expose}" "22"; then
        PRINT "Port 22 not set to be exposed on this host which does not use a JUMPHOST, meaning it will not be accessible at all. Automatically adding port 22 to the exposed ports list." "warning" 0
        expose="${expose}${expose:+ }22"
    fi

    mkdir -p "${dir}"

    printf "%s\\n" "# Auto generated host.env file to be used with the Space ssh module.
# You can enter this host as USER by running \"space -m ssh /ssh/ -e SSHHOSTFILE=host.env\".

# HOSTHOME is the directory on the host where this local host sync to.
HOSTHOME=${hostHome}
# ROUTERADDRESS is the the IP:port within the cluster where this host's Proxy service can be reached at. Most often localIP:2222.
ROUTERADDRESS=
# HOST is the public or private IP of the Host. If using a JUMPHOST, then it is likely the internal IP, of not the it is the public IP.
HOST=
# The user on the Host which will be running the pods in rootless mode. This should NOT be the root user.
USER=snt
# The path to the SSH keyfile used for this user on this Host.
KEYFILE=./id_rsa
# Expose these ports to the public internet
EXPOSE=${expose}
# The super user which can administer the host
SUPERUSER=sntsuper
# The keyfile of the super user
SUPERKEYFILE=./id_rsa_super
# SSH port this Host is listening on.
PORT=22
# Networks for internal traffic, these are important and the settings depend on the subnets of your hosts.
INTERNAL=192.168.0.0/16 10.0.0.0/8 172.16.0.0/11
# Worker hosts are often not exposed to the public internet and to connect to them over SSH a JUMPHOST is needed.
JUMPHOST=${jumphost}" >"${dir}/host.env"

    printf "%s\\n" "active" >"${dir}/host.state"

    PRINT "Host ${host} created" "info" 0
    _PRJ_LOG_C "CREATE_HOST ${host}"
}

_PRJ_CLUSTER_IMPORT_POD_CFG()
{
    local _SPACE_NAME="_PRJ_CLUSTER_IMPORT_POD_CFG"

    local pod="${1}"
    shift

    local hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"

    if [ -z "${hosts}" ]; then
        PRINT "Pod '${pod}' is not attached to this cluster." "error" 0
        return 1
    fi

    local podConfigDir="$(FILE_REALPATH "${PODPATH}/${pod}/config")"

    if [ ! -d "${podConfigDir}" ]; then
        PRINT "Pod '${pod}' has no configs to be imported." "info" 0
        return 0
    fi

    local clusterPodConfigDir="${CLUSTERPATH}/_config/${pod}"
    PRINT "Source: Pod config template dir: ${podConfigDir}" "info" 0
    PRINT "Target: Cluster pod config dir: ${clusterPodConfigDir}" "info" 0

    local configCommit=
    if ! configCommit="$(_UTIL_GET_TAG_DIR "${podConfigDir}")"; then
        return 1
    fi

    if [ -d "${clusterPodConfigDir}" ]; then
        PRINT "cluster config for the pod '${pod}' already exists, will not overwrite" "error" 0
        return 1
    fi

    mkdir -p "${CLUSTERPATH}/_config"

    if ! cp -r "${podConfigDir}" "${clusterPodConfigDir}"; then
        PRINT "Unexpected disk failure importing configs to cluster project." "error" 0
        return 1
    fi

    PRINT "Configs copied" "info" 0

    _PRJ_LOG_C "IMPORT_POD_CFG ${pod}:${configCommit}"
}

_PRJ_GET_CLUSTER_STATUS()
{
    local _SPACE_NAME="_PRJ_GET_CLUSTER_STATUS"
    :
}

_PRJ_CLUSTER_CREATE()
{
    local _SPACE_NAME="_PRJ_CLUSTER_CREATE"

    local basePath="${1}"
    shift

    local clusterName="${1}"
    shift

    if [ "${clusterName}" = "pods" ] || [ "${clusterName}" = "keys" ]; then
        PRINT "'pods' and 'keys' are reserved names" "error" 0
        return 1
    fi

    local CLUSTERPATH="${basePath}/${clusterName}"

    if [ -e "${CLUSTERPATH}" ]; then
        PRINT "Cluster directory already exists" "error" 0
        return 1
    fi

    mkdir -p "${CLUSTERPATH}" &&
    touch "${CLUSTERPATH}/cluster-vars.env" &&
    printf "%s\\n" "${clusterName}" >"${CLUSTERPATH}/cluster-id.txt" &&
    cd "${CLUSTERPATH}" &&
    git init &&
    git add . &&
    git commit -m "Initial" &&
    _PRJ_LOG_C "CREATED-CLUSTER-PROJECT" || return 1
}

_SYNC_RUN()
{
    local _SPACE_NAME="_SYNC_RUN"

    # The sync does the following:

    #   1.  Check if any cluster/host ports are clashing.
    #   2.  Get the git commit chain of IDs.
    #   For each host:
    #   3.  Check so that no other sync is already in progress.
    #   4.  Check on each host that our HEAD is in the same chain as on the host.
    #           If it is behind host HEAD then warn that we are rolling back and require a force flag to continue.
    #           If it is on another branch then warn that we have branched and require a force flag to continue.
    #   For each host again, now in parallel:
    #   5.  Set the HEAD and chain on host to match our local cluster, mark as "syncing".
    #   6.  Download a list of metadata for all pods and releases on host.
    #   7.  For each existing release on the host which does not exist in the cluster project, set it's state to: removed (this will remove everything but keep volumes for the pod.)
    #           This is detached pods or deleted releases. To remove the volumes for a pod a separate garbage collection action need to be performed.
    #   8.  For all releases existing in cluster project but not on host, check if state is "running", if so add it to sync queue.
    #   9.  For all releases existing on both sides:
    #           i) check if config files have changed, if so sync them.
    #           ii) For all releases existing on both sides check if state file has changed, is so sync them.
    #   11.  Mark host as "synced ready".

    local forceSync="${1:-false}"
    shift

    local quite="${1:-false}"
    shift

    if ! _PRJ_CHECK_PORT_CLASHES; then
        return 1
    fi

    local hosts=
    hosts="$(_PRJ_LIST_HOSTS 1)"

    if [ -z "${hosts}" ]; then
        PRINT "No existing active/inactive hosts to sync with." "error" 0
        return 1
    fi

    local list=
    if ! list="$(_SYNC_MK_TMP_FILES "${hosts}")"; then
        PRINT "Could not create tmp file." "error" 0
        return 1
    fi

    local gitCommitChain=""
    local clusterID=

    if ! clusterID="$(_PRJ_GET_CLUSTER_ID)"; then
        PRINT "Cannot get the ID for this cluster project." "error" 0
        _SYNC_RM_TMP_FILES "${list}"
        return 1
    fi

    # Perform step 1 to 4
    if ! _PRJ_IS_CLUSTER_CLEAN; then
        PRINT "The cluster git project is not clean and committed. Cannot continue until it is." "error" 0
        _SYNC_RM_TMP_FILES "${list}"
        return 1
    fi

    if ! gitCommitChain="$(_PRJ_GET_CLUSTER_GIT_COMMIT_CHAIN)"; then
        PRINT "Cannot get the git commit chain in this cluster project." "error" 0
        _SYNC_RM_TMP_FILES "${list}"
        return 1
    fi

    # Get the cluster metadata for each host.
    local host=
    local tmpFile=
    local tuple=
    for tuple in ${list}; do
        host="${tuple%:*}"
        tmpFile="${tuple#*:}"
        local hostClusterMeta=
        if ! hostClusterMeta="$(_SYNC_GET_METADATA "${host}")"; then
            PRINT "Could not communicate with host: ${host}. If this host is to be out of rotation first disable it, if this is a temporary hickup in the network run this command again in a while." "error" 0
            _SYNC_RM_TMP_FILES "${list}"
            return 1
        fi

        # Check to remote has the same cluster ID.
        local remoteClusterID="${hostClusterMeta%%[ ]*}"
        if [ "${remoteClusterID}" != "${clusterID}" ]; then
            PRINT "cluster ID of local project and on host ${host} do not match! Aborting. Maybe the host has to be initiated first?" "error" 0
            _SYNC_RM_TMP_FILES "${list}"
            return 1
        fi

        # Check so that remote git commit chain is behind or on HEAD.
        local remoteChain="${hostClusterMeta#*[ ]}"
        local remainder="${gitCommitChain#${remoteChain}}"
        local remainder2="${remoteChain#${gitCommitChain}}"
        PRINT "Remainder: ${remainder}" "debug" 0

        if [ -z "${remoteChain}" ]; then
            # Fall through
            :
        elif [ -n "${remainder2}" ] && [ "${remainder2}" != "${remoteChain}" ]; then
            if [ "${forceSync}" = "true" ]; then
                PRINT "Force syncing a rollback." "warning" 0 2>>"${tmpFile}"
                # Fall through
            else
                PRINT "Host ${host} HEAD is in front of what we are syncing! If this is a rollback you need to force it." "error" 0
                _SYNC_RM_TMP_FILES "${list}"
                return 1
            fi
        elif [ -z "${remainder}" ]; then
            # We are on HEAD.
            PRINT "Host already on HEAD, checking for updates anyways (idempotent)." "info" 0 2>>"${tmpFile}"
            # Fall through
        elif [ "${remainder}" = "${gitCommitChain}" ]; then
            # This is a branch, throw error
            if [ "${forceSync}" = "true" ]; then
                PRINT "Force syncing a branch onto host." "warning" 0 2>>"${tmpFile}"
                # Fall through
            else
                PRINT "You are trying to sync a branched commit chain to host ${host}. You could force this update to reset the commit chain on host, but it can be dangerous." "error" 0
                PRINT "Local chain: ${gitCommitChain}" "debug" 0
                PRINT "Remote chain: ${remoteChain}" "debug" 0
                PRINT "Remainder: ${remainder}" "debug" 0
                _SYNC_RM_TMP_FILES "${list}"
                return 1
            fi
        else
            local previousCommit="${remoteChain##*[ ]}"
            local head="${gitCommitChain##*[ ]}"
            PRINT "Syncing host up from commit \"${previousCommit}\" to the following HEAD: \"${head}\"" "info" 0 2>>"${tmpFile}"
            # Fall through
        fi
        unset hostClusterMeta
    done
    unset host

    # Get a lock on all hosts.
    local randomToken="$(awk 'BEGIN{min=1;max=65535;srand(); print int(min+rand()*(max-min+1))}')"
    local lockedHosts=""
    local host=
    local tmpFile=
    local tuple=
    for tuple in ${list}; do
        host="${tuple%:*}"
        tmpFile="${tuple#*:}"
        if ! _SYNC_ACQUIRE_LOCK "${host}" "${randomToken}" 2>>"${tmpFile}"; then
            PRINT "Could not acquire lock on host ${host}." "error" 0
            _PRJ_LOG_C "SYNC_LOCK_ACQUIRE_ERROR token:${randomToken} host:${host}"
            # Unlock previously locked
            for host in ${lockedHosts}; do
                _SYNC_RELEASE_LOCK "${host}" "${randomToken}" 2>>"${tmpFile}"
            done
            _SYNC_RM_TMP_FILES "${list}" "${randomToken}"
            return 1
        fi
        lockedHosts="${lockedHosts}${lockedHosts:+,}${host}"
    done
    unset host

    _PRJ_LOG_C "SYNC_LOCK_ACQUIRED token:${randomToken} hosts:${lockedHosts}"
    unset lockedHosts

    ## Now we are all setup to run the sync on all hosts.
    ## We will do this in parallel and if any host fails at this stage
    ## that will not abort the overall process but will be reported in the output.
    ## If a host fails then this sync should be run again or that host should be taken out of rotation.
    ## Syncs are alwaus idempotent, can be run multiple times.


    local timeout="$(($(date +%s)+1200))"
    local pid=
    local pids=""
    local host=
    local tmpFile=
    local tuple=
    for tuple in ${list}; do
        host="${tuple%:*}"
        tmpFile="${tuple#*:}"
        if ! pid="$(_SYNC_RUN2 "${host}" "${gitCommitChain}" 2>"${tmpFile}")"; then
            PRINT "Could not spawn process, aborting. Sync might now be in a halfway state, you should rerun this sync when possible." "error" 0
            # Make it kill any processes immediately.
            timeout=0
            _PRJ_LOG_C "SYNC_ABORTED_ON_ERROR token:${randomToken} host:${host}"
            break
        fi
        pids="${pids}${pids:+ }${pid}"
    done

    # trap INT and kill all subprocesses.
    trap _SYNC_KILL_SUBPROCESSES INT

    # Collect and show all output while we wait for pids to finish
    while true; do
        if [ "$(date +%s)" -gt "${timeout}" ]; then
            # Check so actually timeouted, it could also have been forced timeouted on error above.
            if [ "${timeout}" -gt 0 ]; then
                _PRJ_LOG_C "SYNC_ABORTED_ON_TIMEOUT token:${randomToken}"
            fi
            # Kill all processes
            for pid in ${pids}; do
                PRINT "Kill sub process ${pid} on timeout." "error" 0
                 kill -9 "${pid}" 2>/dev/null
            done
            break
        fi
        # Output to TTY ongoing updates.
        if [ "${quite}" != "true" ]; then
            _SYNC_OUTPUT_INFO "${list}"
        fi
        sleep 1
        for pid in ${pids}; do
            if kill -0 "${pid}" 2>/dev/null; then
                continue 2
            fi
        done
        _PRJ_LOG_C "SYNC_DONE token:${randomToken}"
        break
    done

    local host=
    local tmpFile=
    local tuple=
    for tuple in ${list}; do
        host="${tuple%:*}"
        tmpFile="${tuple#*:}"
        _SYNC_RELEASE_LOCK "${host}" "${randomToken}" 2>>"${tmpFile}"
    done

    # Clear trap
    trap - INT

    _PRJ_LOG_C "SYNC_LOCK_RELEASED token:${randomToken}"

    _SYNC_RM_TMP_FILES "${list}" "${randomToken}"
}

_PRJ_GET_DAEMON_LOG()
{
    local _SPACE_NAME="_PRJ_GET_DAEMON_LOG"

    local host="${1:-}"
    shift

    local hosts=
    if [ -n "${host}" ]; then
        if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
            PRINT "Host ${host} does not exist." "error" 0
            return 1
        fi
        hosts="${host}";
    else
        hosts="$(_PRJ_LIST_HOSTS 1)"
    fi
    unset host

    [ -z "${hosts}" ] && {
        PRINT "No hosts active" "warning" 0
        return 0;
    }

    local host=
    for host in ${hosts}; do
        printf "Daemon logs for host '%s':\\n" "${host}"
        _PRJ_GET_DAEMON_LOG2 "${host}"
    done
}

STRING_SUBSTR()
{
    local _SPACE_NAME="STRING_SUBSTR"

    # shellcheck disable=SC2034
    local __sopriv="${1}"
    shift

    local __index="${1}"
    shift

    local __length="${1}"
    shift

    local __outvar="${1:-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __strlength="${#__sopriv}"

    if [ "${__index}" -lt 0 ]; then
        __index=$((__strlength+__index))
    fi

    if [ "${__index}" -ge 0 ]; then
        if [ "${__length}" = "" ]; then
            __length=$((__strlength-__index))
        fi

        if [ "${__length}" -lt 0 ]; then
            __length=$((__strlength-__index+__length))
        fi

        if [ "$((__index+__length))" -le "${#__sopriv}" ]; then
            local __wildcard=
            STRING_REPEAT "?" "${__index}" "" "__wildcard"
            local __substr="${__sopriv#${__wildcard}}"
            STRING_REPEAT "?" "$((${#__substr}-__length))" "" "__wildcard"
            __substr="${__substr%${__wildcard}}"
            if [ -n "${__outvar}" ]; then
                eval "${__outvar}=\"\${__substr}\""
            else
                printf "%s\\n" "${__outvar}"
            fi
            return 0
        fi

    fi

    if [ -n "${__outvar}" ]; then
        eval "${__outvar}=\"\""
    fi
}

STRING_INDEXOF()
{
    local _SPACE_NAME="STRING_INDEXOF"

    local substr="${1}"
    shift

    local string="${1}"
    shift

    local varname="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local rest="${string%%${substr}*}"

    if [ "${rest}" = "${string}" ]; then
        if [ -n "${varname}" ]; then
            eval "${varname}=\"-1\""
        fi
        return 1
    fi

    if [ -n "${varname}" ]; then
        eval "${varname}=\"${#rest}\""
    fi
    return 0
}

STRING_ESCAPE()
{
    local _SPACE_NAME="STRING_ESCAPE"

    local ___char=
    for ___char in \" \$ \( \) \< \> \| \& \/; do
        case "${2-\"\$}" in
            *${___char}*)
                _STRING_ESCAPE "${1}" "${___char}"
                ;;
        esac
    done
}

_PRJ_LS_POD_RELEASE_STATE()
{
    local _SPACE_NAME="_PRJ_LS_POD_RELEASE_STATE"

    local filterState="${1:-}"
    shift

    local quite="${1:-false}"
    shift

    local podTriple="${1}"
    shift

    if [ -n "${filterState}" ]; then
        if [ "${filterState}" = "running" ] || [ "${filterState}" = "stopped" ] || [ "${filterState}" = "removed" ]; then
            # Good, fall through
            :
        else
            PRINT "State must be running, stopped or removed. Leave blank for all" "error" 0
            return 1
        fi
    fi

    if [ "${podTriple#*:}" != "${podTriple}" ]; then
        PRINT "Do not specify version for pod. Argument only as 'pod[@host]'" "error" 0
        return 1
    fi

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTriple}"; then
        return 1
    fi


    local hosts=
    if [ -n "${host}" ]; then
        if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
            PRINT "Host ${host} does not exist." "error" 0
            return 1
        fi

        hosts="${host}"
    else
        hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
    fi
    unset host

    if [ -z "${hosts}" ]; then
        PRINT "Pod is not attached to any host" "warning" 0
        return
    fi

    local host=
    for host in ${hosts}; do
        if ! podVersion="$(_PRJ_FIND_POD_VERSION "${pod}" "${version}" "${host}")"; then
            #PRINT "Version ${version} not found on host ${host}. Skipping." "info" 0
            continue
        fi

        local podVersions="$(_PRJ_GET_POD_RELEASES "${host}" "${pod}")"
        local podVersion=
        for podVersion in ${podVersions}; do
            local state=
            if ! state="$(_PRJ_GET_POD_RELEASE_STATE "${host}" "${pod}" "${podVersion}")"; then
                continue
            fi
            if [ -n "${filterState}" ]; then
                if [ "${filterState}" != "${state}" ]; then
                    continue
                fi
            fi
            if [ "${quite}" = "true" ]; then
                printf "%s:%s@%s\\n" "${pod}" "${podVersion}" "${host}"
            else
                printf "%s:%s@%s %s\\n" "${pod}" "${podVersion}" "${host}" "${state}"
            fi
        done
    done |sort
}

_PRJ_SET_POD_INGRESS_STATE()
{
    local _SPACE_NAME="_PRJ_SET_POD_INGRESS_STATE"

    local state="${1}"
    shift

    local podTriple=
    for podTriple in "$@"; do
        local pod=
        local version=
        local host=
        if ! _PRJ_SPLIT_POD_TRIPLE "${podTriple}"; then
            return 1
        fi

        local hosts=
        if [ -n "${host}" ]; then
            if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
                PRINT "Host ${host} does not exist." "error" 0
                return 1
            fi

            hosts="${host}"
        else
            hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
        fi
        unset host

        if [ -z "${hosts}" ]; then
            PRINT "Pod '${pod}' is not attached to any host." "warning" 0
            continue
        fi

        local podVersion=
        local host=
        for host in ${hosts}; do
            if ! podVersion="$(_PRJ_FIND_POD_VERSION "${pod}" "${version}" "${host}")"; then
                PRINT "Version ${version} not found on host ${host}. Skipping." "info" 0
                continue
            fi

            local ingressConfFile="pod.ingress.conf"
            local targetPodDir="${CLUSTERPATH}/${host}/pods/${pod}/release/${podVersion}"
            local targetPodIngressConfFile="${targetPodDir}/${ingressConfFile}"

            if [ ! -d "${targetPodDir}" ]; then
                PRINT "Pod ${pod}:${podVersion} not found on host ${host}. Skipping." "warning" 0
                continue
            fi

            PRINT "Set ingress state of release ${podVersion} on host ${host} to ${state}." "info" 0

            if [ "${state}" = "active" ]; then
                if [ -f "${targetPodIngressConfFile}.inactive" ]; then
                    mv "${targetPodIngressConfFile}.inactive" "${targetPodIngressConfFile}"
                fi
            else
                if [ -f "${targetPodIngressConfFile}" ]; then
                    mv "${targetPodIngressConfFile}" "${targetPodIngressConfFile}.inactive"
                fi
            fi

            _PRJ_LOG_P "${host}" "${pod}" "SET_POD_INGRESS_STATE release:${podVersion}=${state}"
        done
    done
}

_PRJ_SIGNAL_POD()
{
    local _SPACE_NAME="_PRJ_SIGNAL_POD"

    local podTriple="${1}"
    shift

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTriple}"; then
        return 1
    fi

    local hosts=
    if [ -n "${host}" ]; then
        if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
            PRINT "Host ${host} does not exist." "error" 0
            return 1
        fi

        hosts="${host}"
    else
        hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
    fi
    unset host

    if [ -z "${hosts}" ]; then
        PRINT "Pod '${pod}' is not attached to any host." "error" 0
        return 1
    fi

    local podVersion=
    local host=
    for host in ${hosts}; do
        if ! podVersion="$(_PRJ_FIND_POD_VERSION "${pod}" "${version}" "${host}")"; then
            PRINT "Version ${version} not found on host ${host}. Skipping." "info" 0
            continue
        fi
        local state="$(_PRJ_GET_POD_RELEASE_STATE "${host}" "${pod}" "${podVersion}")"
        if [ "${state}" = "running" ]; then
            PRINT "Signal ${pod}:${podVersion}@${host} $@" "info" 0
            _PRJ_SIGNAL_POD2 "${pod}" "${podVersion}" "$@"
        else
            PRINT "Pod ${pod}:${podVersion} is not in the running state" "warning" 0
        fi
    done
}

_RELEASE()
{
    local _SPACE_NAME="_RELEASE"

    local podTuple="${1}"
    shift

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTuple}"; then
        return 1
    fi

    if [ -n "${host}" ]; then
        PRINT "Do not provide @host, only pod[:version]" "error" 0
        return 1
    fi

    local mode="${1:-hard}"
    local push="${2:-false}"
    local force="${3:-false}"

    if [ "${mode}" = "soft" ] || [ "${mode}" = "hard" ]; then
        # All good, fall through
        :
    else
        PRINT "Mode must be soft or hard" "error" 0
        return 1
    fi

    if ! _PRJ_IS_CLUSTER_CLEAN; then
        PRINT "The cluster git project is not clean and committed. Cannot continue until it is." "error" 0
        return 1
    fi

    isCompiled="false"
    local podVersion=
    if [ "${version}" = "latest" ]; then
        # Compile new version
        if ! podVersion="$(_PRJ_COMPILE_POD "${pod}" "true")"; then
            return 1
        fi
        isCompiled="true"
    else
        # Either pod version exists or is to be compiled
        local lines=
        lines="$(_PRJ_GET_POD_RELEASE_STATE "${pod}:${version}")"
        if [ -n "${lines}" ]; then
            PRINT "${pod}:${version} does exist, re-release it" "info" 0
            podVersion="${version}"
        else
            # Compile it for the specified version
            if ! podVersion="$(_PRJ_COMPILE_POD "${pod}" "true" "${version}")"; then
                return 1
            fi
            isCompiled="true"
        fi
    fi

    if [ -z "${podVersion}" ]; then
        PRINT "Nothing to do. To re-release this pod, run the release again and specifiy the version, as: ${pod}:version" "error" 0
        return 1
    fi

    # Get a list of the current running versions of the pod.
    local otherVersions="$(_PRJ_LS_POD_RELEASE_STATE "running" "true" "${pod}")"

    local otherVersions2="$(printf "%s\\n" "${otherVersions}" |grep -v "\<${podVersion}\>")"

    if [ "${otherVersions2}" = "${otherVersions}" ]; then
        _PRJ_LOG_C "RELEASE ${pod}:${podVersion}"
    else
        _PRJ_LOG_C "RE-RELEASE ${pod}:${podVersion}"
    fi

    local newline="
"
    STRING_SUBST "otherVersions2" "${newline}" " " 1

    local dir="${PWD}"
    cd "${CLUSTERPATH}"
    local status=
    if [ "${mode}" = "hard" ]; then
        _RELEASE_HARD "${pod}" "${podVersion}" "${otherVersions2}" "${force}" "${isCompiled}"
        status="$?"
    else
        _RELEASE_SOFT "${pod}" "${podVersion}" "${otherVersions2}" "${force}" "${isCompiled}"
        status="$?"
    fi

    cd "${dir}"

    if [ "${status}" -gt 0 ]; then
        PRINT "There was an error releasing. The cluster might be in a incoherent state right now. To resume the release process perform the release again refering to this specific pod version: ${podVersion}" "error" 0
    fi

    return "${status}"
}

_PRJ_LIST_PODS_BY_HOST()
{
    local _SPACE_NAME="_PRJ_LIST_PODS_BY_HOST"

    local host="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does not exist." "error" 0
        return 1
    fi

    (cd "${CLUSTERPATH}" && find . -maxdepth 4 -mindepth 4 -regex "^./${host}/pods/[^.][^/]*/log\.txt$" |cut -d/ -f4)
}

_PRJ_GET_POD_STATUS()
{
    local _SPACE_NAME="_PRJ_GET_POD_STATUS"

    local readiness="${1:-false}"
    shift

    local quite="${1:-false}"
    shift

    local podTriple="${1}"
    shift

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTriple}"; then
        return 1
    fi

    local hosts=
    if [ -n "${host}" ]; then
        if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
            PRINT "Host ${host} does not exist" "error" 0
            return 1
        fi

        hosts="${host}"
    else
        hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
    fi
    unset host

    if [ -z "${hosts}" ]; then
        PRINT "Pod is not attached to any host." "warning" 0
        return 1
    fi

    local totalCount="0"
    local countReady="0"
    local podVersion=
    local host=
    for host in ${hosts}; do
        if ! podVersion="$(_PRJ_FIND_POD_VERSION "${pod}" "${version}" "${host}")"; then
            continue
        fi
        totalCount="$((totalCount+1))"

        if [ "${readiness}" = "true" ]; then
            local status=
            if status="$(_PRJ_GET_POD_STATUS2 "${host}" "${pod}" "${podVersion}" "readiness")"; then
                if [ "${status}" = "ready" ]; then
                    countReady="$((countReady+1))"
                    if [ "${quite}" = "true" ]; then
                        # We can do an early quit here
                        return 0
                    fi
                fi
            fi
        else
            # General info
            # TODO: how to present this
            local status=
            if status="$(_PRJ_GET_POD_STATUS2 "${host}" "${pod}" "${podVersion}" "status")"; then
                printf "Host: %s, Pod: %s\\nStatus: %s\\n" "${host}" "${pod}:${podVersion}" "${status}"
            else
                printf "Host: %s, Pod: %s\\nStatus: unknown\\n" "${host}" "${pod}:${podVersion}"
            fi
        fi
    done

    if [ "${readiness}" = "true" ]; then
        if [ "${quite}" = "true" ]; then
            if [ "${countReady}" -gt 0 ]; then
                return 0
            else
                return 1
            fi
        fi
        printf "%s/%s\\n" "${countReady}" "${totalCount}"
    fi
}

_PRJ_POD_SHELL()
{
    local _SPACE_NAME="_PRJ_POD_SHELL"

    local podTriple="${1}"
    shift

    local container="${1}"
    shift

    local useBash="${1:-false}"
    shift

    local pod=
    local version=
    local host=
    if ! _PRJ_SPLIT_POD_TRIPLE "${podTriple}"; then
        return 1
    fi

    local hosts=
    if [ -n "${host}" ]; then
        if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
            PRINT "Host ${host} does not exist" "error" 0
            return 1
        fi

        hosts="${host}"
    else
        hosts="$(_PRJ_LIST_ATTACHEMENTS "${pod}")"
    fi
    unset host

    if [ -z "${hosts}" ]; then
        PRINT "Pod is not attached to any host." "warning" 0
        return
    fi

    local podVersion=
    local host=
    for host in ${hosts}; do
        if ! podVersion="$(_PRJ_FIND_POD_VERSION "${pod}" "${version}" "${host}")"; then
            PRINT "Pod ${pod}:${version}@${host} does not exist" "warning" 0
            continue
        fi

        PRINT "Enter shell of ${pod}:${podVersion}@${host}" "info" 0
        if ! _REMOTE_EXEC "${host}" "pod_shell" "${pod}" "${podVersion}" "${container}" "${useBash}"; then
            PRINT "Could not enter pod ${pod}:${podVersion}@${host}" "error" 0
        fi
    done
}

_PRJ_HOST_SHELL()
{
    local _SPACE_NAME="_PRJ_HOST_SHELL"

    local host="${1}"
    shift

    local superUser="${1}"
    shift

    local useBash="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does not exist" "error" 0
        return 1
    fi

    if [ "${superUser}" = "true" ]; then
        PRINT "Enter superuser shell of host ${host}" "info" 0
        local hostEnv="${CLUSTERPATH}/${host}/host-superuser.env"
        _REMOTE_EXEC "${host}:${hostEnv}" "host_shell" "${useBash}"
    else
        PRINT "Enter shell of host ${host}" "info" 0
        _REMOTE_EXEC "${host}" "host_shell" "${useBash}"
    fi

}

_PRJ_DOES_HOST_EXIST()
{
    local _SPACE_NAME="_PRJ_DOES_HOST_EXIST"

    local hostsPath="${1}"
    shift

    local host="${1}"
    shift

    [ -f "${hostsPath}/${host}/host.env" ]
}

_UTIL_GET_TMP_DIR()
{
    local _SPACE_NAME="_UTIL_GET_TMP_DIR"
    mktemp -d 2>/dev/null || mktemp -d -t 'sometmpdir'
}

_PRJ_EXTRACT_INGRESS()
{
    local _SPACE_NAME="_PRJ_EXTRACT_INGRESS"

    local podfile="${1}"
    shift

    local tmpDir="${1}"
    shift

    local host="${1}"
    shift

    local pod="${1}"
    shift

    local excludeClusterPorts="${1}"
    shift

    local ingressConf="${podfile}.ingress.conf"

    if [ ! -f "${ingressConf}" ]; then
        return
    fi

    # Loop through the conf file and extract each ingress block
    local out_conf_lineno=0
    local rule_count=0
    while [ "${out_conf_lineno}" -gt -1 ]; do
        rule_count=$((rule_count+1))
        local ingress=
        local importance=
        local bind=
        local protocol=
        local host=
        local path_beg=
        local path_end=
        local path=
        local clusterport=
        local redirect_to_https=
        local redirect_location=
        local redirect_prefix=
        local errorfile=
        CONF_READ "${ingressConf}" "ingress importance bind protocol clusterport host path path_end path_beg redirect_to_https redirect_location redirect_prefix errorfile"
        if [ -n "${bind}" ] && [ -n "${protocol}" ]; then
            # Do nothing, fall through
            :
        else
            if [ "${out_conf_lineno}" -eq -1 ]; then
                continue
            fi
            PRINT "Ingress config is not complete." "error" 0
            return 1
        fi

        if [ -n "${clusterport}" ]; then
            # Check if the clusterport is on the ignore list
            if STRING_ITEM_INDEXOF "${excludeClusterPorts}" "${clusterport}"; then
                PRINT "Ignoring ingress for clusterPort ${clusterport}." "warning" 0
                continue;
            fi

            # TODO: Check so that clusterport is within the accepted range.
        fi

        local bindport="${bind%*:}"

        # Check if this bind (port) is already defined and if so that is has the same protocol.
        local file="$(cd "${tmpDir}" && find -name "${bind}-*.frontend")"
        if [ -n "${file}" ]; then
            # It is, now check so that it is defined for the same protocol.
            local proto2="${file#*-}"
            proto2="${proto2%.frontend}"
            if [ "${proto2}" != "${protocol}" ]; then
                PRINT "Mismatching protocols for bind ${bind} (${proto2} and ${protocol}). Only one protocol allowed per bind." "error" 1
                return 1
            fi
        fi

        local frontendfile="${tmpDir}/${bind}-${protocol}.frontend"

        # Check some mutually exclusive rules
        if [ "${protocol}" = "tcp" ]; then
            if [ -n "${path_end}" ] || [ -n "${path_beg}" ] || [ -n "${path}" ]; then
                PRINT "Protocol tcp cannot have path or path_beg rules." "error" 0
                return 1
            fi
            if [ "${redirect_to_https}" = "true" ] || [ -n "${redirect_location}" ] || [ -n "${redirect_prefix}" ] || [ -n "${errorfile}" ]; then
                PRINT "Protocol tcp cannot have redirect rules or errorfiles" "error" 0
                return 1
            fi
        fi

        if [ "${protocol}" = "https" ]; then
            if [ "${redirect_to_https}" = "true" ]; then
                PRINT "Protocol https cannot have redirect_to_https rule" "error" 0
                return 1
            fi
        fi

        if { [ -n "${path_beg}" ] || [ -n "${path_end}" ]; } && [ -n "${path}" ]; then
            PRINT "path_beg and path_end are mutually exclusive to path" "error" 0
            return 1
        fi

        # Calculate criteria ACLs
        ## Do path, path_beg, path_end
        ## path is mutuallay exclusing with path_beg and path_end (checked above),
        ## path_beg and path_end can be evaluated together in the same ACL
        local criteria=""  # Only used to group identical ingress criterias together
        local aclnames=""
        local acls=""

        ## Figure out which ACLs we will have
        if [ -n "${path}" ]; then
            aclnames="${aclnames}${aclnames:+ }PATH-${rule_count}"
        fi
        if [ -n "${path_beg}" ]; then
            aclnames="${aclnames}${aclnames:+ }PATH_BEG-${rule_count}"
        fi
        if [ -n "${path_end}" ]; then
            aclnames="${aclnames}${aclnames:+ }PATH_END-${rule_count}"
        fi
        if [ -n "${host}" ]; then
            aclnames="${aclnames}${aclnames:+ }HOST-${rule_count}"
        fi

        ## Build the matching ACL rules
        if [ -n "${path_beg}" ]; then
            path_beg="$(printf "%s\\n" "${path_beg}" |tr ' ' '\n' |sort |tr '\n' ' ')"
            STRING_TRIM "path_beg"
            criteria="${criteria}{ path_beg ${path_beg}}"
            acls="acl PATH_BEG-${rule_count} path_beg ${path_beg}
"
        fi

        if [ -n "${path_end}" ]; then
            path_end="$(printf "%s\\n" "${path_end}" |tr ' ' '\n' |sort |tr '\n' ' ')"
            STRING_TRIM "path_end"
            criteria="${criteria}{ path_end ${path_end}}"
            acls="${acls}acl PATH_END-${rule_count} path_end ${path_end}
"
        fi

        if [ -n "${path}" ]; then
            path="$(printf "%s\\n" "${path}" |tr ' ' '\n' |sort |tr '\n' ' ')"
            STRING_TRIM "path"
            criteria="${criteria}{ path ${path}}"
            acls="acl PATH-${rule_count} path ${path}
"
        fi

        # We also add the port to hostname if any other port than http/80 or https/443
        local addporttohostname="false"
        if { [ "${protocol}" = "https" ] && [ "${bindport}" != "443" ]; } ||
            { [ "${protocol}" = "http" ] && [ "${bindport}" != "80" ]; }; then
            addporttohostname="true"
        fi

        # Sort host names, this is important so that identical rules are grouped together.
        local host1=""
        local host2=""
        if [ -n "${host}" ]; then
            host="$(printf "%s\\n" "${host}" |tr '[:upper:]' '[:lower:]' |tr ' ' '\n' |sort -f)"
            local hostname=
            local hostnames=""
            for hostname in ${host}; do
                hostnames="${hostnames}${hostname:+ }${hostname}"
                # Check if it is exact match or subdomain wildcard.
                local hostname2="${hostname##*[*]}"
                if [ "${hostname2}" != "${hostname}" ]; then
                    # This is a wildcard
                    host2="${host2}${host2:+ }${hostname2}"
                    if [ "${addporttohostname}" = "true" ]; then
                        host2="${host2} ${hostname2}:${bindport}"
                    fi
                else
                    host1="${host1}${host1:+ }${hostname}"
                    if [ "${addporttohostname}" = "true" ]; then
                        host1="${host1} ${hostname}:${bindport}"
                    fi
                fi
            done
            criteria="${criteria}{ host ${hostnames}}"

            if [ -n "${host1}" ]; then
                if [ "${protocol}" = "tcp" ]; then
                    host1="req.ssl_sni -i ${host1}"
                else
                    host1="hdr(host) -i ${host1}"
                fi
            fi
            if [ -n "${host2}" ]; then
                if [ "${protocol}" = "tcp" ]; then
                    host2="req.ssl_sni,lower -m end ${host2}"
                else
                    host2="hdr(host),lower -m end ${host2}"
                fi
            fi
        fi

        if [ -n "${host1}" ]; then
            acls="${acls}acl HOST-${rule_count} ${host1}
"
        fi
        if [ -n "${host2}" ]; then
            acls="${acls}acl HOST-${rule_count} ${host2}
"
        fi

        local type=
        if [ "${redirect_to_https}" = "true" ] || [ -n "${redirect_location}" ] || [ -n "${redirect_prefix}" ] || [ -n "${errorfile}" ]; then
            type="general"
            if [ -n "${clusterport}" ]; then
                PRINT "clusterport is defined but backend is ignored since there are redirection rules present." "warning" 0
            fi
        else
            type="server"
        fi

        # Take hash on bind, protocol, criterions and importance.
        # This is to uniquely identify and group together backends which have the exact same rules and frontend.
        local hash=
        if ! STRING_HASH "${bind}-${protocol}_${type}-${importance}-${criteria}" "hash"; then
            return 1
        fi

        local backendName="${hash}"
        # Will get sorted on importance when generating config
        local frontendmatch="${importance} ${backendName}"
        # Check in frontend file if hash exists, else add it.
        FILE_ROW_PERSIST "${frontendmatch}" "${frontendfile}"
        local aclfile="${frontendfile}.${backendName}"
        if [ ! -f "${aclfile}" ]; then
            printf "%s" "${acls}" >"${aclfile}"
            printf "%s\\n" "use_backend ${backendName} if ${aclnames}" >>"${aclfile}"
        fi

        # Now add server to backend
        # See what extra configs we have on the server.
        local backendLine=""

        if [ "${redirect_to_https}" = "true" ]; then
            backendLine="redirect scheme https code 301"
        elif [ -n "${redirect_location}" ]; then
            backendLine="redirect location ${redirect_location} code 301"
        elif [ -n "${redirect_prefix}" ]; then
            backendLine="redirect prefix ${redirect_prefix} code 301"
        elif [ -n "${errorfile}" ]; then
            backendLine="errorfile ${errorfile}"
        else
            # proxy must be defined in /etc/hosts to the IP where the proxy process is listening.
            backendLine="server clusterPort-${clusterport} proxy:${clusterport} send-proxy"
        fi

        local backendFile="${tmpDir}/${hash}-${protocol}_${type}.backend"
        FILE_ROW_PERSIST "${backendLine}" "${backendFile}"
    done
}

_PRJ_GET_POD_RUNNING_RELEASES()
{
    local _SPACE_NAME="_PRJ_GET_POD_RUNNING_RELEASES"

    local host="${1}"
    shift

    local pod="${1}"
    shift

    local versions="$(_PRJ_GET_POD_RELEASES "${host}" "${pod}")"

    for version in ${versions}; do
        local state="$(_PRJ_GET_POD_RELEASE_STATE "${host}" "${pod}" "${version}")"
        if [ "${state}" = "running" ]; then
            printf "%s\\n" "${version}"
        fi
    done
}

STRING_ITEM_INDEXOF()
{
    local _SPACE_NAME="STRING_ITEM_INDEXOF"

    local __s="${1}"
    shift

    local __item="${1}"
    shift

    local __outvar="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __item2=
    local __count=0
    for __item2 in ${__s}; do
        if [ "${__item}" = "${__item2}" ]; then
            if [ -n "${__outvar}" ]; then
                eval "${__outvar}=\"\${__count}\""
            fi
            return 0
        fi
        __count=$((__count+1))
    done
    if [ -n "${__outvar}" ]; then
        eval "${__outvar}=\"-1\""
    fi
    return 1
}

_PRJ_GEN_INGRESS_CONFIG2()
{
    local _SPACE_NAME="_PRJ_GEN_INGRESS_CONFIG2"

    local tmpDir="${1}"
    shift

    local ingressTplDir="${1}"
    shift

    # check so that there are frontend and backend files generated before continuing
    local frontends=
    frontends="$( cd "${tmpDir}" && find -regex "^./[0-9]+-[^-]+\.frontend" )"
    local backends=
    backends="$( cd "${tmpDir}" && find -regex "^./[^-]+-.+\.backend" )"

    if [ -z "${frontends}" ] || [ -z "${backends}" ]; then
        PRINT "No ingress has been generated." "warning" 0
    fi

    if ! cat "${ingressTplDir}/main.tpl"; then
        return 1
    fi

    # For all .frontend files,
    # sort rows on importance (first column) desc,
    # create frontend line in haproxy.cfg with bind and possble ssl cert params.
    # create a rule for each criterion and use hash as backend
    local frontend=
    for frontend in ${frontends}; do
        local bind=
        bind="${frontend%%-*}"
        bind="${bind#*/}"
        local protocol=
        protocol="${frontend%.frontend}"
        protocol="${protocol#*-}"
        local frontendextra=""
        if [ "${protocol}" = "https" ]; then
            frontendextra=" ssl crt /mnt/haproxy-certs"
        fi
        printf "\\nfrontend %s-%s\\n" "${bind}" "${protocol}"
        printf "    bind :%s%s\\n" "${bind}" "${frontendextra}"
        if ! awk '{$0="    "$0; print}' "${ingressTplDir}/frontend-${protocol}.tpl"; then
            return 1
        fi
        local sortedfile="${tmpDir}/${frontend}.sorted"
        sort "${tmpDir}/${frontend}" -n -r > "${sortedfile}"
        while IFS='' read -r line; do
            local backendName="${line#* }"
            backendName="${backendName%% *}"
            local aclfile="${tmpDir}/${frontend}.${backendName}"
            if ! awk '{$0="    "$0; print}' "${aclfile}"; then
                return 1
            fi
        done < "${sortedfile}"
    done

    # For all .backend files,
    # create backend entries in haproxy.cfg
    # and add all servers to it
    local backend=
    for backend in ${backends}; do
        local name=
        name="${backend%%-*}"
        name="${name#*/}"
        local mode=
        mode="${backend%.backend}"
        mode="${mode#*-}"
        printf "\\nbackend %s\\n" "${name}"
        if ! awk '{$0="    "$0; print}' "${ingressTplDir}/backend-${mode}.tpl"; then
            return 1
        fi
        while IFS='' read -r line; do
            printf "    %s\\n" "${line}"
        done < "${tmpDir}/${backend}"
    done
}

TEXT_EXTRACT_VARIABLES()
{
    local _SPACE_NAME="TEXT_EXTRACT_VARIABLES"

    local text="${1}"
    shift

    printf "%s\\n" "${text}" |
        awk '
            {
                while (match($0,/(\$\{[A-Za-z_][0-9A-Za-z_]*\})/))
                {
                    result = substr($0,RSTART+2,RLENGTH-3);
                    print result;
                    $0 = substr($0,RSTART+RLENGTH);
                }
            }' |
        sort |uniq
}

TEXT_VARIABLE_SUBST()
{
    local _SPACE_NAME="TEXT_VARIABLE_SUBST"

    local text="${1}"
    shift

    local variables="${1}"
    shift

    local values="${1}"
    shift

    local value=
    local varname=
    for varname in ${variables}; do
        value="$(printf "%s\\n" "${values}" |grep -m 1 "^${varname}=")"
        value="${value#${varname}=}"
        varname="\${${varname}}"
        STRING_ESCAPE "varname" '/'
        STRING_ESCAPE "value" '/'
        text="$(printf "%s\\n" "${text}" |sed "s/${varname}/${value}/g")"
    done

    printf "%s\\n" "${text}"
}

TEXT_FILTER()
{
    local _SPACE_NAME="TEXT_FILTER"
    local awkscript='
    BEGIN {
        count=0
        keep=1
    }

    {
        if (match($0,/^#endif[ ]*$/))
        {
            count--;
            if (count == 0)
            {
                keep=1
                next
            }
        }
    }

    {
        if (match($0,/^#if([n]?)def[ ]?([^ ]*)$/))
        {
            count++;
            if (count == 1)
            {
                if (length(substr($2,RSTART,RLENGTH)) >0)
                {
                    if (substr($1,RSTART,RLENGTH)=="#ifdef")
                    {
                        keep=1
                    }
                    else if (substr($1,RSTART,RLENGTH)=="#ifndef")
                    {
                        keep=0
                    }
                }
                else
                {
                    if (substr($1,RSTART,RLENGTH)=="#ifdef")
                    {
                        keep=0
                    }
                    else if (substr($1,RSTART,RLENGTH)=="#ifndef")
                    {
                        keep=1
                    }
                }
                next
            }
        }
    }

    {
        if (match($0,/^#if([n]?)true[ ]?([^ ]*)$/))
        {
            count++;
            if (count == 1)
            {
                if (substr($2,RSTART,RLENGTH)=="true")
                {
                    keep=1
                }
                else
                {
                    keep=0
                }
                if (substr($1,RSTART,RLENGTH)=="#iftrue")
                {
                    keep=keep
                }
                else if (substr($1,RSTART,RLENGTH)=="#ifntrue")
                {
                    keep=!keep
                }

                next
            }
        }
    }

    {
        if (keep)
        {
            print
        }
    }

    END {
        if (count >0)
        {
            print "Error: Missing #endif" > "/dev/stderr"
        }
    }
'
    local text="$(cat)"
    local text2="${text}"
    while true; do
        text2="$(printf "%s\\n" "${text}" |awk "${awkscript}")"
        if [ "${text2}" = "${text}" ]; then
            break
        fi
        text="${text2}"
    done
    printf "%s\\n" "${text}"
}

STRING_IS_ALL()
{
    local _SPACE_NAME="STRING_IS_ALL"

    local __str="${1}"
    shift

    local __pattern="${1}"
    shift

    local __m="[!${__pattern}]"
    case "${__str}" in
        (*${__m}*)
            return 1
            ;;
        *)
            ;;
    esac
}

STRING_SUBST()
{
    local _SPACE_NAME="STRING_SUBST"

    local __varname="${1}"
    local __rstring=
    eval "__rstring=\"\${$1}\""
    shift

    local __subst="${1}"
    shift

    local __replace="${1}"
    shift

    local __global="${1:-0}"
    shift $(( $# > 0 ? 1 : 0 ))

    local __lstring=
    local __string=""
    while true; do
        __lstring="${__rstring%%${__subst}*}"
        if [ "${__lstring}" = "${__rstring}" ]; then
            __string="${__string}${__rstring}"
            break
        fi
        __string="${__string}${__lstring}${__replace}"
        __rstring="${__rstring#*${__subst}}"
        if [ "${__global}" -ne 1 ]; then
            __string="${__string}${__rstring}"
            break
        fi
    done
    eval "${__varname}=\"\${__string}\""
}

_PRJ_GET_POD_RELEASE_STATE()
{
    local _SPACE_NAME="_PRJ_GET_POD_RELEASE_STATE"

    local host="${1}"
    shift

    local pod="${1}"
    shift

    local podVersion="${1}"
    shift

    local targetPodDir="${CLUSTERPATH}/${host}/pods/${pod}/release/${podVersion}"
    local stateFile="pod.state"
    local targetPodStateFile="${targetPodDir}/${stateFile}"

    if [ -f "${targetPodStateFile}" ]; then
        local state="$(cat "${targetPodStateFile}")"
        printf "%s\\n" "${state}"
    else
        return 1
    fi
}

_PRJ_FIND_POD_VERSION()
{
    local _SPACE_NAME="_PRJ_FIND_POD_VERSION"

    local pod="${1}"
    shift

    local podVersion="${1}"
    shift

    local host="${1}"
    shift

    local dir="${CLUSTERPATH}/${host}/pods/${pod}/release"

    if [ ! -d "${dir}" ]; then
        return 1
    fi

    if [ "${podVersion}" = "latest" ]; then
        podVersion="$(cd "${dir}" && find . -maxdepth 1 -type d |cut -b3- |grep -v "-" |sort -t. -k1,1n -k2,2n -k3,3n |tail -n1)"
    fi

    if [ -z "${podVersion}" ]; then
        return 1
    fi

    if [ ! -d "${dir}/${podVersion}" ]; then
        return 1
    fi

    printf "%s\\n" "${podVersion}"
}

_PRJ_SPLIT_POD_TRIPLE()
{
    local _SPACE_NAME="_PRJ_SPLIT_POD_TRIPLE"

    local triple="${1}"
    shift

    host="${triple#*@}"
    if [ "${host}" = "${triple}" ]; then
        host=""
    fi

    local podVersion="${triple%@*}"
    pod="${podVersion%:*}"
    if [ "${pod}" != "${podVersion}" ]; then
        version="${podVersion#*:}"
    fi

    if [ -z "${version}" ]; then
        version="latest"
    fi

    if [ -z "${pod}" ]; then
        PRINT "Invalid pod format provided, expecting pod[:version][@host]" "error" 0
        return 1
    fi
}

_PRJ_GET_POD_LOGS2()
{
    local _SPACE_NAME="_PRJ_GET_POD_LOGS2"

    local host="${1}"
    shift

    local pod="${1}"
    shift

    local podVersion="${1}"
    shift

    local timestamp="${1}"
    shift

    local limit="${1}"
    shift

    local streams="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does not exist." "error" 0
        return 1
    fi

    local i=
    local status=
    _REMOTE_EXEC "${host}" "logs" "${pod}" "${podVersion}" "${timestamp}" "${limit}" "${streams}"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        return 0
    else
        PRINT "Could not get logs from host." "error" 0
        return "${status}"
    fi
}

STRING_IS_NUMBER()
{
    local _SPACE_NAME="STRING_IS_NUMBER"

    local __s="${1}"
    shift

    local __allowNegative="${1:-0}"

    local __s2="${__s#-}"

    if [ "${__s}" != "${__s2}" ] && [ "${__allowNegative}" != 1 ]; then
        return 1
    fi

    case "${__s2}" in
        ''|*[!0-9]*)
            return 1
            ;;
        *)
            ;;
    esac
}

_PRJ_ENUM_STATE()
{
    local _SPACE_NAME="_PRJ_ENUM_STATE"

    local state="${1}"
    shift

    if [ "${state}" = "removed" ] || [ "${state}" = "running" ] || [ "${state}" = "stopped" ]; then
        return 0
    fi

    return 1
}

_PRJ_LOG_P()
{
    local _SPACE_NAME="_PRJ_LOG_P"

    local host="${1}"
    shift

    local pod="${1}"
    shift

    local action="${1}"
    shift

    local logFile="${CLUSTERPATH}/${host}/pods/${pod}/log.txt"

    printf "%s %s %s %s\\n" "$(date +"%F %T")" "$(date +%s)" "${USER}" "${action}" >>"${logFile}"
}

_UTIL_GET_TAG_DIR()
{
    local _SPACE_NAME="_UTIL_GET_TAG_DIR"

    local dir="${1}"
    shift

    if [ ! -d "${dir}" ]; then
        PRINT "${dir} does not exist." "error" 0
        return 1
    fi

    local text=
    if ! text="$(cd "${dir}" && git status -s --porcelain -- ./)"; then
        PRINT "${dir} is not a git repo" "error" 0
        return 1
    fi

    if [ -n "${text}" ]; then
        PRINT "${dir} has uncommitted changes." "warning" 0
        printf "%s\\n" "<unknown>"
        return 0
    fi

    local commitId=
    if ! commitId="$(cd "${dir}" && git rev-list -1 HEAD -- ./)"; then
        PRINT "${dir} is not comitted." "warning" 0
        printf "%s\\n" "<unknown>"
        return 0
    fi

    local tag=
    tag="$(cd "${dir}" && git describe "${commitId}" --always --tags 2>/dev/null)"

    tag="${tag:-${commitId}}"

    printf "%s\\n" "${tag}"
}

_PRJ_COPY_POD_CONFIGS()
{
    local _SPACE_NAME="_PRJ_COPY_POD_CONFIGS"

    local clusterPath="${1}"
    shift

    local host="${1}"
    shift

    local pod="${1}"
    shift

    local podVersion="${1}"
    shift

    local config=

    if [ ! -d "${clusterPath}/_config/${pod}" ]; then
        PRINT "Missing ${clusterPath}/_config/${pod}" "error" 0
        return 1
    fi

    if ! ( cd "${clusterPath}/_config/${pod}"
        for config in $(find . -mindepth 1 -maxdepth 1 -type d -not -path './.*'  |cut -b3-); do
            if [ ! -d "${config}" ] || [ "${config#_}" != "${config}" ]; then
                # Not dir or underscore prefixed config, skip it.
                continue
            fi
            if ! mkdir -p "${clusterPath}/${host}/pods/${pod}/release/${podVersion}/config/${config}"; then
                return 1
            fi
            if ! cp -r "${clusterPath}/_config/${pod}/${config}" "${clusterPath}/${host}/pods/${pod}/release/${podVersion}/config"; then
                return 1
            fi
        done
    ); then
        PRINT "Could not copy configs to pod release." "error" 0
        return 1
    fi
}

_PRJ_CHKSUM_POD_CONFIGS()
{
    local _SPACE_NAME="_PRJ_CHKSUM_POD_CONFIGS"

    local clusterPath="${1}"
    shift

    local host="${1}"
    shift

    local pod="${1}"
    shift

    local podVersion="${1}"
    shift

    local config=

    if [ ! -d  "${clusterPath}/${host}/pods/${pod}/release/${podVersion}/config/" ]; then
        return 0
    fi

    if ! ( cd "${clusterPath}/${host}/pods/${pod}/release/${podVersion}/config/"
        for config in $(find . -mindepth 1 -maxdepth 1 -type d -not -path './.*'  |cut -b3-); do
            # Create checksum
            local dir="${clusterPath}/${host}/pods/${pod}/release/${podVersion}/config/${config}"
            local chksum=
            if ! chksum="$(FILE_DIR_CHECKSUM_CONTENT "${dir}")"; then
                PRINT "Could not take checksum" "error" 0
                return 1
            fi
            local file="${clusterPath}/${host}/pods/${pod}/release/${podVersion}/config/${config}.txt"
            printf "%s\\n" "${chksum}" >"${file}"
        done
    ); then
        PRINT "Could not copy configs to pod release." "error" 0
        return 1
    fi
}

_UTIL_GET_TAG_FILE()
{
    local _SPACE_NAME="_UTIL_GET_TAG_FILE"

    local file="${1}"
    shift

    local dir="${file%/*}"
    local file2="${file##*/}"

    if ! [ -f "${file}" ]; then
        PRINT "Could not find file: ${file}" "error" 0
        return 1
    fi

    if ! ( cd "${dir}" && git rev-parse --show-toplevel >/dev/null 2>&1 ); then
        PRINT "File ${file} is not in git repo." "error" 0;
        return 1
    fi

    local commitId=
    commitId="$(cd "${dir}" && git log --oneline -- "${file2}" 2>/dev/null |head -n1 |cut -d' ' -f1)"

    if [ -z "${commitId}" ]; then
        PRINT "Could not get commitId for file ${file}. It should be committed to the repo first." "warning" 0
        return 0
    fi

    local tag=
    tag="$(cd "${dir}" && git describe "${commitId}" --always --tags 2>/dev/null)"

    tag="${tag:-${commitId}}"

    # Check if the file is dirty
    local s=
    s="$(cd "${dir}" && git diff --name-only -- "${file2}" 2>/dev/null)"
    if [ -n "${s}" ]; then
        PRINT "File ${file} has changes, should be committed first." "warning" 0
        printf "%s\\n" "<unknown>"
        return 0
    fi

    s="$(cd "${dir}" && git diff --name-only --cached -- "${file2}" 2>/dev/null)"
    if [ -n "${s}" ]; then
        PRINT "File ${file} has changes, should be committed first." "warning" 0
        printf "%s\\n" "<unknown>"
        return 0
    fi

    printf "%s\\n" "${tag}"
}

STRING_TRIM()
{
    local _SPACE_NAME="STRING_TRIM"

    # shellcheck disable=SC2034
    local __sopriv=
    eval "__sopriv=\"\${${1}}\""
    # shellcheck disable=SC2034
    local __tab="	"
    while true; do
        eval "${1}=\"\${$1#\"\${$1%%[! ]*}\"}\""
        eval "${1}=\"\${$1%\"\${$1##*[! ]}\"}\""
        eval "${1}=\"\${$1#\"\${$1%%[!\$__tab]*}\"}\""
        eval "${1}=\"\${$1%\"\${$1##*[!\$__tab]}\"}\""
        if eval "[ \"\${${1}}\" = \"\${__sopriv}\" ]"; then
            break
        fi
        eval "__sopriv=\"\${${1}}\""
    done
}

_PRJ_GET_FREE_HOSTPORT()
{
    local _SPACE_NAME="_PRJ_GET_FREE_HOSTPORT"

    local host="${1}"
    shift

    local reservedPorts="${1}"

    local dir="${CLUSTERPATH}/${host}/pods"

    # Extract hostPorts from the proxy config lines.
    local usedPorts="$(cd "${dir}" && find . -regex "^./[^.][^/]*/release/[^.][^/]*/pod.proxy.conf\$" -exec cat {} \; |cut -d ':' -f2)"

    local port=29999
    local p=
    while true; do
        port=$((port+1))
        for p in ${usedPorts}; do
            if [ "${p}" -eq "${port}" ]; then
                continue 2
            fi
        done
        for p in ${reservedPorts}; do
            if [ "${p}" -eq "${port}" ]; then
                continue 2
            fi
        done
        break
    done

    if [ "${port}" -gt "31999" ]; then
        PRINT "All ports between 30000-31999 are already claimed on host ${host}. You need to purge some old versions of pods to free up claims on host ports." "error" 0
        return 1
    fi

    printf "%s\\n" "${port}"
}

_PRJ_GET_FREE_CLUSTERPORT()
{
    local _SPACE_NAME="_PRJ_GET_FREE_CLUSTERPORT"

    local reservedPorts="${1}"

    # Extract clusterPorts from the proxy config lines from all pods on all hosts.
    local usedPorts="$(cd "${CLUSTERPATH}" && find . -regex "^./[^.][^/]*/pods/[^.][^/]*/release/[^.][^/]*/pod.proxy.conf\$" -exec cat {} \; |cut -d ':' -f1)"

    local port=60999
    local p=
    while true; do
        port=$((port+1))
        for p in ${usedPorts}; do
            if [ "${p}" -eq "${port}" ]; then
                continue 2
            fi
        done
        for p in ${reservedPorts}; do
            if [ "${p}" -eq "${port}" ]; then
                continue 2
            fi
        done
        break
    done

    if [ "${port}" -gt "63999" ]; then
        PRINT "All cluster ports between 61000-63999 are already claimed on cluster. You need to purge some old versions of pods to free up claims on cluster ports." "error" 0
        return 1
    fi

    printf "%s\\n" "${port}"
}

_PRJ_IS_POD_ATTACHED()
{
    local _SPACE_NAME="_PRJ_IS_POD_ATTACHED"

    local hostsPath="${1}"
    shift

    local host="${1}"
    shift

    local pod="${1}"
    shift

    [ -f "${hostsPath}/${host}/pods/${pod}/log.txt" ]
}

_REMOTE_EXEC()
{
    local _SPACE_NAME="_REMOTE_EXEC"

    local host="${1}"
    shift

    local action="${1}"
    shift

    local hostEnv="${host#*:}"
    if [ "${hostEnv}" != "${host}" ]; then
        host="${host%%:*}"
    else
        hostEnv="${CLUSTERPATH}/${host}/host.env"
    fi

    PRINT "Connect to host ${host} with action: ${action}." "debug"

    # Load host env file
    if [ ! -f "${hostEnv}" ]; then
        PRINT "${hostEnv} file does not exist." "error" 0
        return 10
    fi

    local HOSTHOME=
    local JUMPHOST=
    local value=
    local varname=
    for varname in HOSTHOME JUMPHOST; do
        value="$(grep -m 1 "^${varname}=" "${hostEnv}")"
        value="${value#*${varname}=}"
        STRING_TRIM "value"
        eval "${varname}=\"\${value}\""
    done

    if [ -z "${HOSTHOME}" ]; then
        PRINT "HOSTHOME must be defined in ${hostEnv}." "error" 0
        return 10
    fi

    if [ "${JUMPHOST}" = "local" ]; then
        PRINT "Connecting directly on local disk using shell" "debug"
    fi

    # Check if we have the script exported already
    local RUN=
    case "${action}" in
        "pack_release_data")
            if [ -n "${REMOTE_PACK_RELEASEDATA}" ]; then
                RUN="${REMOTE_PACK_RELEASEDATA}"
            fi
            ;;
        "set_commit_chain")
            if [ -n "${REMOTE_SET_COMMITCHAIN}" ]; then
                RUN="${REMOTE_SET_COMMITCHAIN}"
            fi
            ;;
        "acquire_lock")
            if [ -n "${REMOTE_ACQUIRE_LOCK}" ]; then
                RUN="${REMOTE_ACQUIRE_LOCK}"
            fi
            ;;
        "release_lock")
            if [ -n "${REMOTE_RELEASE_LOCK}" ]; then
                RUN="${REMOTE_RELEASE_LOCK}"
            fi
            ;;
        "get_host_metadata")
            if [ -n "${REMOTE_GET_HOSTMETADATA}" ]; then
                RUN="${REMOTE_GET_HOSTMETADATA}"
            fi
            ;;
        "upload_archive")
            if [ -n "${REMOTE_UPLOAD_ARCHIVE}" ]; then
                RUN="${REMOTE_UPLOAD_ARCHIVE}"
            fi
            ;;
        "unpack_archive")
            if [ -n "${REMOTE_UNPACK_ARCHIVE}" ]; then
                RUN="${REMOTE_UNPACK_ARCHIVE}"
            fi
            ;;
        "init_host")
            if [ -n "${REMOTE_INIT_HOST}" ]; then
                RUN="${REMOTE_INIT_HOST}"
            fi
            ;;
        "setup_host")
            if [ -n "${REMOTE_HOST_SETUP}" ]; then
                RUN="${REMOTE_HOST_SETUP}"
            fi
            ;;
        "logs")
            if [ -n "${REMOTE_LOGS}" ]; then
                RUN="${REMOTE_LOGS}"
            fi
            ;;
        "pod_status")
            if [ -n "${REMOTE_POD_STATUS}" ]; then
                RUN="${REMOTE_POD_STATUS}"
            fi
            ;;
        "signal")
            if [ -n "${REMOTE_SIGNAL}" ]; then
                RUN="${REMOTE_SIGNAL}"
            fi
            ;;
        "daemon-log")
            if [ -n "${REMOTE_DAEMON_LOG}" ]; then
                RUN="${REMOTE_DAEMON_LOG}"
            fi
            ;;
        "create_superuser")
            if [ -n "${REMOTE_CREATE_SUPERUSER}" ]; then
                RUN="${REMOTE_CREATE_SUPERUSER}"
            fi
            ;;
        "disable_root")
            if [ -n "${REMOTE_DISABLE_ROOT}" ]; then
                RUN="${REMOTE_DISABLE_ROOT}"
            fi
            ;;
        "pod_shell")
            if [ -n "${REMOTE_POD_SHELL}" ]; then
                RUN="${REMOTE_POD_SHELL}"
            fi
            ;;
        "host_shell")
            if [ -n "${REMOTE_HOST_SHELL}" ]; then
                RUN="${REMOTE_HOST_SHELL}"
            fi
            ;;
        *)
            # Unknown action type
            PRINT "Unknown action type: ${action}." "error"
            return 10
            ;;
    esac

    if [ -n "${RUN}" ]; then
        if [ "${JUMPHOST}" = "local" ]; then
            sh -c "${RUN}" "sh" "${HOSTHOME}" "$@"
        else
            SSH "" "" "" "" "" "${hostEnv}" "" "${RUN}" "${HOSTHOME}" "$@"
        fi
    else
        # Run the space target to do this. This is usually only done in dev mode.
        if [ "${JUMPHOST}" = "local" ]; then
            space -L "${SPACE_LOG_LEVEL}" -f "${0}" /_remote_plumbing/${action}/ -- "${HOSTHOME}" "$@"
        else
            space -L "${SPACE_LOG_LEVEL}" -f "${0}" /_remote_plumbing/${action}/ -m ssh /wrap/ -e SSHHOSTFILE="${hostEnv}" -- "${HOSTHOME}" "$@"
        fi
    fi
}

SSH_KEYGEN()
{
    local _SPACE_NAME="SSH_KEYGEN"

    local sshkeyfile="${1}"
    shift

    local bits="${1:-2048}"
    shift $(( $# > 0 ? 1 : 0 ))

    local sshpubkeyfile="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))


    PRINT "Generate new key pair." "info"

    # Don't copy the pub key file to it self.
    if [ "${sshpubkeyfile}" = "${sshkeyfile}.pub" ]; then
        sshpubkeyfile=
    fi

    if [ -f "${sshkeyfile}" ]; then
        PRINT "Keyfile: ${sshkeyfile} already exists, not generating new." "warning"
        return 0
    fi
    FILE_MKDIRP "$(dirname "${sshkeyfile}")" && ssh-keygen -f "${sshkeyfile}" -b "${bits}" -N ""
    if [ "$?" != "0" ]; then
        return 1
    fi
    if [ "${sshpubkeyfile-}" != "" ]; then
        FILE_MKDIRP "$(dirname ${sshpubkeyfile})" && FILE_CP "${sshkeyfile}.pub" "${sshpubkeyfile}"
    fi
}

_PRJ_GET_CLUSTER_ID()
{
    local _SPACE_NAME="_PRJ_GET_CLUSTER_ID"

    local clusterIdFile="${CLUSTERPATH}/cluster-id.txt"

    cat "${clusterIdFile}" 2>/dev/null
}

_PRJ_LOG_C()
{
    local _SPACE_NAME="_PRJ_LOG_C"

    local action="${1}"
    shift

    local logFile="${CLUSTERPATH}/log.txt"

    printf "%s %s %s %s\\n" "$(date +"%F %T")" "$(date +%s)" "${USER}" "${action}" >>"${logFile}"
}

_PRJ_IS_CLUSTER_CLEAN()
{
    local _SPACE_NAME="_PRJ_IS_CLUSTER_CLEAN"

    local dirtyFiles=
    if ! dirtyFiles="$(cd "${CLUSTERPATH}" && git status -s --porcelain)"; then
        return 1
    fi

    if [ -n "${dirtyFiles}" ]; then
        # Check if it is the log files which are dirty, that we will allow.
        local fileNames="$(printf "%s\\n" "${dirtyFiles}" |awk '{print $NF}')"
        local file=
        for file in ${fileNames}; do
            if [ "${file}" = "log.txt" ]; then
                continue
            fi
            if [ "${file#_synclogs/}" != "${file}" ]; then
                continue
            fi
            if [ "${file#*/*/*/log.txt}" != "${file}" ]; then
                continue
            fi
            return 1
        done
    fi

    return 0
}

_PRJ_GET_CLUSTER_GIT_COMMIT_CHAIN()
{
    local _SPACE_NAME="_PRJ_GET_CLUSTER_GIT_COMMIT_CHAIN"

    local chain=
    chain="$(cd "${CLUSTERPATH}" && git log --reverse --oneline --all |cut -d' ' -f1)" 2>/dev/null

    if [ -z "${chain}" ]; then
        return 1
    fi

    local newline="
"
    STRING_SUBST "chain" "${newline}" " " 1

    printf "%s\\n" "${chain}"
}

_SYNC_GET_METADATA()
{
    local _SPACE_NAME="_SYNC_GET_METADATA"

    local host="${1}"
    shift

    local status=
    local data=
    data="$(_REMOTE_EXEC "${host}" "get_host_metadata")"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        printf "%s\\n" "${data}"
        return 0
    elif [ "${status}" -eq 10 ]; then
        return 1
    fi

    PRINT "Could not get metadata." "error" 0
    # Failed
    return 1
}

_SYNC_RUN2()
{
    local _SPACE_NAME="_SYNC_RUN2"

    local host="${host}"
    shift

    local gitCommitChain="${1}"
    shift

    local pid=

    # Spawn off subprocess
    (
        if ! _SYNC_SET_CHAIN "${host}" "${gitCommitChain}"; then
            PRINT "Could not set the commit id chain on the host." "error" 0
            return 1
        fi

        local hostReleaseData=
        if ! hostReleaseData="$(_SYNC_DOWNLOAD_RELEASE_DATA "${host}")"; then
            PRINT "Could not download release data from the host." "error" 0
            return 1
        fi

        local status=
        local tmpDir=
        tmpDir="$(_SYNC_BUILD_UPDATE_ARCHIVE "${host}" "${hostReleaseData}")"
        status="$?"
        if [ "${status}" -eq 0 ]; then
            PRINT "Performing updates..." "info" 0
            if ! _SYNC_PERFORM_UPDATES "${host}" "${tmpDir}"; then
                PRINT "Could not build update archive." "error" 0
                rm -rf "${tmpDir}"
                return 1
            fi
            rm -rf "${tmpDir}"
        elif [ "${status}" -eq 1 ]; then
            # Error
            PRINT "Could not build update archive." "error" 0
            return 1
        else
            # No updates to bring
            PRINT "No updates to be made." "info" 0
            return 0
        fi
    )&
    pid=$!

    printf "%s\\n" "${pid}"
}

_SYNC_OUTPUT_INFO()
{
    local _SPACE_NAME="_SYNC_OUTPUT_INFO"

    local isFinal="${1}"
    shift

    [ -t 1 ]
    local isTTY=$?

    if [ "${isTTY}" = 0 ]; then
        _UTIL_CLEAR_SCREEN
        :
    else
        # Output is redirected.
        # don't clear screen,
        # only output when final.
        if [ "${isFinal}" = 0 ]; then
            return 0
        fi
    fi

    local tuple=
    for tuple in ${list}; do
        local host="${tuple%:*}"
        local tmpFile="${tuple#*:}"
        printf "%s\\n" "[SYNC]  Host: ${host}"
        cat "${tmpFile}"
        printf "\\n"
    done
}

_SYNC_ACQUIRE_LOCK()
{
    local _SPACE_NAME="_SYNC_ACQUIRE_LOCK"

    local host="${1}"
    shift

    local token="${1}"
    shift

    local seconds=10

    PRINT "Acquire lock using token: ${token}" "info" 0

    local status=
    _REMOTE_EXEC "${host}" "acquire_lock" "${token}" "${seconds}"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        return 0
    elif [ "${status}" -eq 2 ]; then
        PRINT "Could not acquire lock. Some other sync process might be happening simultanously, aborting. Please try again in a few minutes." "error" 0
        return 2
    elif [ "${status}" -eq 10 ]; then
        return 1
    fi

    # Failed
    PRINT "Could not acquire lock." "error" 0
    return 1
}

_SYNC_RELEASE_LOCK()
{
    local _SPACE_NAME="_SYNC_RELEASE_LOCK"

    local host="${1}"
    shift

    local token="${1}"
    shift

    local i=
    local status=
    # Try three times before failing
    for i in 1 2 3; do
        _REMOTE_EXEC "${host}" "release_lock" "${token}"
        status="$?"
        if [ "${status}" -eq 0 ]; then
            return 0
        elif [ "${status}" -eq 2 ]; then
            PRINT "Could not release lock, it might not be our lock." "error" 0
            return 2
        elif [ "${status}" -eq 10 ]; then
            return 1
        fi
    done

    # Failed
    PRINT "Could not release lock." "error" 0
    return 1
}

_SYNC_KILL_SUBPROCESSES()
{
    local _SPACE_NAME="_SYNC_KILL_SUBPROCESSES"

    _PRJ_LOG_C "SYNC_ABORTED_BY_USER token:${randomToken}"

    PRINT "Abruptly abort syncing on ctrl-c..." "error" 0
    for pid in ${pids}; do
        PRINT "Kill sub process ${pid}." "info" 0
        kill -9 "${pid}" 2>/dev/null
    done
    _SYNC_RM_TMP_FILES "${list}" "${randomToken}"
    kill -9 $$ 2>/dev/null
}

_SYNC_MK_TMP_FILES()
{
    local _SPACE_NAME="_SYNC_MK_TMP_FILES"

    local hosts="${1}"
    shift

    local list=""
    local host=
    for host in ${hosts}; do
        local tmpFile=
        if ! tmpFile="$(_UTIL_GET_TMP_FILE)"; then
            return 1
        fi
        list="${list}${list:+ }${host}:${tmpFile}"
    done

    printf "%s\\n" "${list}"
}

_SYNC_RM_TMP_FILES()
{
    local _SPACE_NAME="_SYNC_RM_TMP_FILES"

    local list="${1}"
    shift

    local token="${1:-}"

    if [ -n "${token}" ]; then
        local ts="$(date +%s)"
        local logDir="${CLUSTERPATH}/_synclogs"
        mkdir -p "${logDir}"
        local logFile="${logDir}/${ts}.${token}.sync.log.txt"
        _SYNC_OUTPUT_INFO "${list}" >"${logFile}"
        PRINT "Logfile stored at: ${logFile}" "info" 0
    fi

    local host=
    local tmpFile=
    local tuple=
    for tuple in ${list}; do
        host="${tuple%:*}"
        tmpFile="${tuple#*:}"
        rm "${tmpFile}"
    done
}

_PRJ_CHECK_PORT_CLASHES()
{
    local _SPACE_NAME="_PRJ_CHECK_PORT_CLASHES"

    local err=0
    local host=
    hosts="$(_PRJ_LIST_HOSTS 0)"
    for host in ${hosts}; do
        # Get all cluster ports on host
        local dir="${CLUSTERPATH}/${host}/pods"
        # Extract clusterPorts from the proxy config lines.
        local clusterPorts="$(cd "${dir}" && find . -regex "^./[^.][^/]*/release/[^.][^/]*/pod.proxy.conf\$" -exec cat {} \; |cut -d ':' -f1 |sort)"
        # Extract hostPorts from the proxy config lines.
        local hostPorts="$(cd "${dir}" && find . -regex "^./[^.][^/]*/release/[^.][^/]*/pod.proxy.conf\$" -exec cat {} \; |cut -d ':' -f2 |sort)"

        local duplicateHostPorts="$(printf "%s\\n" "${hostPorts}" |uniq -d)"

        # Check if there are any duplicate host ports in usage on the host.
        if [ -n "${duplicateHostPorts}" ]; then
            PRINT "Duplicate usage of host ports detected on host ${host}: ${duplicateHostPorts}" "error" 0
            err=1
        fi

        # Check if any hostport is interfering with any clusterport
        local clashingPorts="$( { printf "%s\\n" "${hostPorts}" |uniq; printf "%s\\n" "${clusterPorts}" |uniq; } |sort |uniq -d)"
        if [ -n "${clashingPorts}" ]; then
            PRINT "Clashing of cluster and host ports detected on host ${host}: ${clashingPorts}" "error" 0
            err=1
        fi
    done

    return "${err}"
}

_PRJ_GET_DAEMON_LOG2()
{
    local _SPACE_NAME="_PRJ_GET_DAEMON_LOG2"

    local host="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does not exist." "error" 0
        return 1
    fi

    local status=
    _REMOTE_EXEC "${host}" "daemon-log"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        return 0
    fi

    PRINT "Could not get daemon log from host" "error" 0

    # Failed
    return "${status}"
}

STRING_REPEAT()
{
    local _SPACE_NAME="STRING_REPEAT"

    local __string="${1}"
    shift

    local __count="${1}"
    shift

    local __separator="${1}"
    shift

    local __outvar="${1}"
    shift

    local __repeatedstring=""
    while [ "${__count}" -gt 0 ]; do
        __count=$((__count-1))
        __repeatedstring="${__repeatedstring}${__string}"
        if [ "${__count}" -gt 0 ]; then
            __repeatedstring="${__repeatedstring}${__separator}"
        fi
    done

    eval "${__outvar}=\"\${__repeatedstring}\""
}

_STRING_ESCAPE()
{
    local _SPACE_NAME="_STRING_ESCAPE"
    local __right=
    local __result=""
    eval "__right=\$${1}"
    local __left=
    while true; do
        # Cut from right up until last occurrence of char.
        __left="${__right%%${2}*}"
        if [ "${__left}" = "${__right}" ]; then
            # Done
            __result="${__result}${__left}"
            break
        fi
        __right="${__right#$__left}"
        # This seems to be necessary the remove the escapes properly.
        __right="${__right#*${2}}"
        # Now cut away from right all escapes, one by one..
        local __escapes=""
        local __left2=
        while true; do
            __left2="${__left%[\\]}"
            if [ "${__left2}" = "${__left}" ]; then
                # No more escapes
                break
            fi
            # Escape encountered
            __escapes="${__escapes}\\"
            __left="${__left2}"
        done
        # Double the number of escapes and add one.
        __result="${__result}${__left}${__escapes}${__escapes}\\${2}"
    done
    eval "${1}=\${__result}"
}

_PRJ_GET_POD_RELEASES()
{
    local _SPACE_NAME="_PRJ_GET_POD_RELEASES"

    local host="${1}"
    shift

    local pod="${1}"
    shift

    (cd "${CLUSTERPATH}/${host}" && find . -maxdepth 5 -mindepth 5 -regex "^./pods/[^.][^/]*/release/[^.][^/]*/pod\$" |cut -d/ -f5)
}

_PRJ_SIGNAL_POD2()
{
    local _SPACE_NAME="_PRJ_SIGNAL_POD2"

    local pod="${1}"
    shift

    local podVersion="${1}"
    shift

    local status=
    _REMOTE_EXEC "${host}" "signal" "${pod}" "${podVersion}" "$@"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        return 0
    fi

    PRINT "Could not signal pod on host." "error" 0

    # Failed
    return "${status}"
}

_RELEASE_HARD()
{
    local _SPACE_NAME="_RELEASE_HARD"

    local pod="${1}"
    shift

    local podVersion="${1}"
    shift

    local otherVersions="${1}"
    shift

    local force="${1}"
    shift

    PRINT "********* Perform hard release of ${pod}:${podVersion} *********" "info" 0

    if [ -n "${otherVersions}" ]; then
        PRINT "********* Retire other versions of the pod." "info" 0
        # Remove the other running pod versions
        if ! _PRJ_SET_POD_RELEASE_STATE "removed" ${otherVersions}; then
            return 1
        fi
        # Remove the other version of the pod from the ingress configuration
        if ! _PRJ_SET_POD_INGRESS_STATE "inactive" ${otherVersions}; then
            return 1
        fi
    fi

    local currentState="$(_PRJ_GET_POD_RELEASE_STATE "${pod}:${podVersion}" "true")"
    if [ "${currentState}" != "running" ]; then
        PRINT "Set pod version ${podVersion} to be 'running'" "info" 0
        if ! _PRJ_SET_POD_RELEASE_STATE "running" "${pod}:${podVersion}"; then
            return 1
        fi
    else
        PRINT "Pod version already in the 'running' state" "info" 0
    fi

    _PRJ_SET_POD_INGRESS_STATE "active" "${pod}:${podVersion}"

    PRINT "********* GENERATE INGRESS *********" "info" 0
    if ! _PRJ_GEN_INGRESS_CONFIG; then
        PRINT "Could not generate ingress" "error" 0
        return 1
    fi

    if ! _PRJ_UPDATE_POD_CONFIG "ingress"; then
        PRINT "Could not update ingress pod config" "error" 0
        return 1
    fi

    if ! { git add . && git commit -q -m "Hard release ${pod}:${podVersion}, retire other versions, update ingress"; } then
        PRINT "Could not commit changes" "error" 0
        return 1
    fi

    PRINT "********* GENERATE INGRESS DONE *********" "info" 0

    PRINT "********* SYNCING *********" "info" 0

    if ! _SYNC_RUN "${force}" "true"; then
        return 1
    fi

    if ! { git add . && git commit -q -m "Update sync log after releasing ${pod}:${podVersion}"; } then
        PRINT "Could not commit changes" "error" 0
        return 1
    fi

    if [ "${push}" = "true" ]; then
        if ! git push -q; then
            PRINT "Could not push repo to remote" "error" 0
            return 1
        fi
    fi

    PRINT "********* RELEASE DONE *********" "info" 0
}

_RELEASE_SOFT()
{
    local _SPACE_NAME="_RELEASE_SOFT"

    local pod="${1}"
    shift

    local podVersion="${1}"
    shift

    local otherVersions="${1}"
    shift

    local force="${1}"
    shift

    local isCompiled="${1}"
    shift

    PRINT "********* Perform soft release of ${pod}:${podVersion} *********" "info" 0

    local podStateUpdated="false"
    local currentState="$(_PRJ_GET_POD_RELEASE_STATE "${pod}:${podVersion}" "true")"
    if [ "${currentState}" != "running" ]; then
        PRINT "Set pod version ${podVersion} to be 'running'" "info" 0
        if ! _PRJ_SET_POD_RELEASE_STATE "running" "${pod}:${podVersion}"; then
            return 1
        fi
        podStateUpdated="true"
    else
        PRINT "Pod version already in the 'running' state" "info" 0
    fi

    # Make sure the pods ingress is active
    _PRJ_SET_POD_INGRESS_STATE "active" "${pod}:${podVersion}"

    # Only commit if any changes were made.
    # Don't push changes here, because we might want to rollback.
    if ! _PRJ_IS_CLUSTER_CLEAN; then
        if ! { git add . && git commit -q -m "Soft release ${pod}:${podVersion}"; } then
            return 1
        fi
    fi

    PRINT "********* SYNCING *********" "info" 0
    # If force is set, only force on the first sync, the coming syncs will then be in line
    if ! _SYNC_RUN "${force}" "true"; then
        return 1
    fi

    PRINT "********* Wait for new release to run... *********" "info" 0

    # Wait for a while to get the status of the new release
    local podStatus=
    local now="$(date +%s)"
    local timeout="$((now+30))"
    while true; do
        sleep 2
        if _PRJ_GET_POD_STATUS "true" "true" "${pod}:${podVersion}" 2>/dev/null; then
            break
        fi

        now="$(date +%s)"
        if [ "$((now > timeout))" -eq 0 ]; then
            PRINT "Timeout trying to get pod readiness, aborting now. This could be due to a problem with the pod it self or due to network issues. The cluster might now be in a skewed state. Consider mannually removing ${pod}:${podVersion} if it was released." "error" 0
            return 1
        fi
    done

    PRINT "New release is now running" "info" 0
    PRINT "Remove other versions from ingress and update the ingress" "info" 0

    if [ -n "${otherVersions}" ]; then
        # Remove the other version of the pod from the ingress configuration
        if ! _PRJ_SET_POD_INGRESS_STATE "inactive" ${otherVersions}; then
            return 1
        fi
    fi

    # New release is up and running, regenerate the ingress
    # Note that if the new version uses the same clusterPorts as the previous version then
    # it will start recieving traffic as soon as it is running.
    # To have a fully isolated handover of traffic a new clusterPort must be used for the new release.
    #
    # This ingress conf regeneration might not change anything in the ingress.
    if ! _PRJ_GEN_INGRESS_CONFIG; then
        PRINT "Could not generate ingress" "error" 0
        return 1
    fi

    if ! _PRJ_UPDATE_POD_CONFIG "ingress"; then
        PRINT "Could not update ingress pod config" "error" 0
        return 1
    fi

    # Even if no ingress conf was changed, there will by new logfiles, so this commit should not fail.
    if ! { git add . && git commit -q -m "Remove other running versions from ingress: ${otherVersions}. Update ingress for ${pod}:${podVersion}"; } then
        PRINT "Could not commit changes" "error" 0
        return 1
    fi

    # TODO: how to know if ingress got updated
    if true; then
        PRINT "********* SYNCING *********" "info" 0
        if ! _SYNC_RUN "" "true"; then
            return 1
        fi

        # Wait for the new ingress conf to get updated
        PRINT "Waiting for ingress to get updated..." "info" 0
        sleep 20
    fi

    if [ -n "${otherVersions}" ]; then
        # Remove the other pod versions
        if ! _PRJ_SET_POD_RELEASE_STATE "removed" ${otherVersions}; then
            return 1
        fi
        git add . && git commit -m "Retire other running versions: ${otherVersions}"
        if [ "${push}" = "true" ]; then
            if ! git push -q; then
                PRINT "Could not push repo to remote" "error" 0
                return 1
            fi
        fi
        PRINT "********* SYNCING *********" "info" 0
        _SYNC_RUN "" "true"
    fi

    git add . && git commit -m "Update sync log after releasing ${pod}:${podVersion}"
    if [ "${push}" = "true" ]; then
        if ! git push -q; then
            PRINT "Could not push repo to remote" "error" 0
            return 1
        fi
    fi

    PRINT "********* RELEASE DONE *********" "info" 0
}

_PRJ_GET_POD_STATUS2()
{
    local _SPACE_NAME="_PRJ_GET_POD_STATUS2"

    local host="${1}"
    shift

    local pod="${1}"
    shift

    local podVersion="${1}"
    shift

    local query="${1}"
    shift

    if ! _PRJ_DOES_HOST_EXIST "${CLUSTERPATH}" "${host}"; then
        PRINT "Host ${host} does not exist." "error" 0
        return 1
    fi

    local status=
    _REMOTE_EXEC "${host}" "pod_status" "${pod}" "${podVersion}" "${query}"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        return 0
    fi

    PRINT "Could not get pod status from host." "error" 0

    # Failed
    return "${status}"
}

CONF_READ()
{
    local _SPACE_NAME="CONF_READ"

    local conffile="${1}"
    shift

    local keys="${1}"
    shift

    if [ ! -f "${conffile}" ]; then
        PRINT "Conf file ${conffile} is missing." "error"
        return 1
    fi

    local _lineno=${out_conf_lineno:-0}
    local _currentno=-1
    local line=
    while true; do
        while IFS='' read -r line; do
            _currentno="$((_currentno + 1))"
            if [ "${_currentno}" -lt "${_lineno}" ]; then
                # Burn some lines
                continue
            fi
            # See if this line is anything good.
            STRING_TRIM "line"
            if [ "${line##\#*}" = "" ]; then
                # Is comment line.
                continue
            fi
            local val="${line#*[\ ]}"
            local key="${line%%${val}}"
            STRING_TRIM "val"
            STRING_TRIM "key"
            # Check if the key is in the list.
            local _okkey=
            while true; do
                for _okkey in ${keys}; do
                    if [ "${_okkey}" = "${key}" ]; then
                        break 2
                    fi
                done
                    # Key not in list, skip it and continue reading file.
                    continue 2
            done

            if eval "[ \"\${${key}:+set}\" != \"set\" ]"; then
                eval "${key}=\"\${val}\""
            else
                # Do not overwrite a value, it's time to stop.
                break 2
            fi
        done < "${conffile}"
        # If we get here then we have read all the file,
        # we'll signal that we are done by setting the $out_conf_lineno variable to -1.
        out_conf_lineno="-1"
        return 0
    done
    # We come here when a "block" has been read, but there could still be more to come.

    # If this was not declared as local with caller,
    # then it becomes a global variable.
    out_conf_lineno="${_currentno}"
}

FILE_ROW_PERSIST()
{
    local _SPACE_NAME="FILE_ROW_PERSIST"

    local row="${1}"
    shift

    local file="${1}"
    shift

    PRINT "Make sure that row exist in ${file}: ${row}" "debug"

    grep -q "^${row}\$" "${file}" 2>/dev/null
    local status="$?"
    if [ "${status}" = "2" ]; then
        PRINT "File not found: ${file}, create it and add row." "debug"
        FILE_APPEND_ROW "${row}" "${file}"
    elif [ "${status}" = "1" ]; then
        PRINT "Row does not exist, add row." "debug"
        FILE_APPEND_ROW "${row}" "${file}"
    fi
}

STRING_HASH()
{
    local _SPACE_NAME="STRING_HASH"

    local __str="${1}"
    shift

    local __outvar="${1}"
    shift

    local SHASUMBIN=
    if command -v sha256sum >/dev/null; then
        SHASUMBIN="sha256sum"
    elif command -v shasum >/dev/null; then
        SHASUMBIN="shasum -a 256"
    fi

    if [ -z "${SHASUMBIN}" ]; then
        return 1
    fi

    local __hash=
    __hash=$(printf "%s\\n" "${__str}" |${SHASUMBIN}) || { return 1; }
    __hash="${__hash%%[ ]*}"
    eval "${__outvar}=\"\${__hash}\""
}

FILE_DIR_CHECKSUM_CONTENT()
{
    local _SPACE_NAME="FILE_DIR_CHECKSUM_CONTENT"

    local dir="${1}"
    shift

    local _SHASUMBIN=
    if command -v sha256sum >/dev/null; then
        _SHASUMBIN=sha256sum
    elif command -v sha1sum >/dev/null; then
        _SHASUMBIN=sha1sum
    elif command -v shasum >/dev/null; then
        _SHASUMBIN="shasum -a 256"
    elif command -v md5sum >/dev/null; then
        _SHASUMBIN="md5sum"
    else
        return 1
    fi

    (cd "${dir}" && find . -type f -exec ${_SHASUMBIN} {} \; |sort -k2 |${_SHASUMBIN} |cut -f 1 -d' ')
}

SSH()
{
    local _SPACE_NAME="SSH"

    local hosts="${1:-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local users="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local keyfiles="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local ports="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local flagses="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local hostfile="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local shell="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    local command="${1-}"
    shift $(( $# > 0 ? 1 : 0 ))

    # Args are used as "$@" and are passed along.

    local is_terminal=
    # 0 must be terminal for ssh to accept the -t flag
    # stdout/stderr must also be terminal to use terminal.
    # We really do not want terminal if we are to capture any output (cause we get carriage returns).
    if [ -t 0 ] && [ -t 1 ] && [ -t 2 ]; then
        is_terminal=1
    fi

    local out_sshcommand=""
    _SSH_BUILD_COMMAND
    if [ "$?" -gt 0 ]; then
        return 1
    fi

    if [ "${is_terminal}" = "1" ]; then
        out_sshcommand="ssh -t ${out_sshcommand}"
    else
        out_sshcommand="ssh ${out_sshcommand}"
    fi

    PRINT "${out_sshcommand}" "debug"
    PRINT "Connecting to: ${hosts}" "debug"

    if [ -z "${shell}" ]; then
        # No shell given, run in login shell.
        if [ -n "${command}" ]; then
            PRINT "No shell defined, running in default login shell." "debug"
            # We need to wrap it in function to let it use the args as it pleases.
            command="__sshwrap()
             {
                $command
             }
             __sshwrap"
            local args=
            local arg=
            for arg in "$@"; do
                STRING_ESCAPE arg '$"'
                args="${args}${args:+ }\"${arg}\""
            done
            eval "${out_sshcommand} \"\$command\" \$args"
        else
            PRINT "No shell defined, entering default login shell." "debug"
            eval "${out_sshcommand}"
        fi
    else
        # Run in specified shell.
        if [ -n "${command}" ]; then
            # Run command in defined shell (via login shell).
            PRINT "Run command in defined shell: ${shell}."  "debug"
            # shellcheck disable=SC2034
            local command2="
RUN=\$(cat <<\"SPACEGAL_SAYS_END_OF_FINITY_\"
${command}
SPACEGAL_SAYS_END_OF_FINITY_
)
${shell} -c \"\$RUN\" \"${shell}\""
            # Note: first argument to $RUN is the shell interpretor name provided as $0,
            # same as when using default shell, to keep consistency.
            local arg=
            for arg in "$@"; do
                STRING_ESCAPE arg '$"'
                command2="${command2} \"${arg}\""
            done
            # Add newline
            command2="${command2}
"
            eval "${out_sshcommand} \"\$command2\""
        else
            PRINT "Enter defined shell: ${shell}." "debug"
            eval "${out_sshcommand} -- \"\${shell}\""
        fi
    fi
}

FILE_MKDIRP()
{
    local _SPACE_NAME="FILE_MKDIRP"

    local dir="$*"

    PRINT "Creating directories: ${dir}." "debug"
    mkdir -p ${dir}
    if [ "$?" -gt 0 ]; then
        PRINT "Could not create directory: ${dir}." "error"
        return 1
    fi
}

FILE_CP()
{
    local _SPACE_NAME="FILE_CP"

    local src="${1}"
    shift

    local dest="${1}"
    shift

    PRINT "Copy file: ${src} ${dest}" "debug"

    cp "${src}" "${dest}"
    if [ "$?" -gt 0 ]; then
        PRINT "Could not copy from ${src} to ${dest}." "error"
        return 1
    fi
}

_SYNC_SET_CHAIN()
{
    local _SPACE_NAME="_SYNC_SET_CHAIN"

    local host="${1}"
    shift

    local gitCommitChain="${1}"
    shift

    local status=
    _REMOTE_EXEC "${host}" "set_commit_chain" "${gitCommitChain}"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        return 0
    elif [ "${status}" -eq 10 ]; then
        return 1
    fi

    # Failed
    PRINT "Could not set chain." "error" 0
    return 1
}

_SYNC_DOWNLOAD_RELEASE_DATA()
{
    local _SPACE_NAME="_SYNC_DOWNLOAD_RELEASE_DATA"

    local host="${1}"
    shift

    local status=
    local data=
    data="$(_REMOTE_EXEC "${host}" "pack_release_data")"
    status="$?"
    if [ "${status}" -eq 0 ]; then
        printf "%s\\n" "${data}"
        return 0
    elif [ "${status}" -eq 10 ]; then
        return 1
    fi

    # Failed
    return "${status}"
}

_SYNC_BUILD_UPDATE_ARCHIVE()
{
    local _SPACE_NAME="_SYNC_BUILD_UPDATE_ARCHIVE"

    local host="${1}"
    shift

    local releaseData="${1}"
    shift

    local tmpDir=
    if ! tmpDir="$(_UTIL_GET_TMP_DIR)"; then
        return 1
    fi

    local hostState="$(_PRJ_GET_HOST_STATE "${host}")"

    PRINT "Using tmp dir ${tmpDir}" "debug"

    # Compare cluster-hosts.txt on host with what we have locally.
    local hostsRouter="$(_PRJ_GET_ROUTER_HOSTS)"
    local updateHosts="0"
    local item=
    for item in ${releaseData}; do
        local hosts="${item#:hosts:}"
        if [ "${hosts}" != "${item}" ]; then
            # Compare list of hosts to current active list.
            if [ "${hosts}" != "${hostsRouter}" ]; then
                updateHosts="1"
            fi
            break
        fi
    done

    if [ "${updateHosts}" = "1" ]; then
        # We want to update this, create file
        PRINT "Add updated list of hosts to the update archive." "info" 0
        local newline="
"
        STRING_SUBST "hostsRouter" ";" "${newline}"
        printf "%s\\n" "${hostsRouter}"  >"${tmpDir}/cluster-hosts.txt"
    fi

    #### PODS
    # First phase, check compared to what is existing on the host,
    # which pod releases to remove, which to update state of,
    # and which configs to update.
    # item is either
    # pod:release:state, or
    # pod:release:config:chksum
    local prefix="${CLUSTERPATH}/${host}/pods"
    local item=
    for item in ${releaseData}; do
        if [ "${item#:hosts:}" != "${item}" ]; then
            # Not relevant for pods
            continue
        fi
        local pod="${item%%:*}"
        local release="${item#*:}"
        release="${release%%:*}"
        local stateOrConfigChksum="${item#*:*:}"
        local chkSum="${stateOrConfigChksum#*:}"
        local state=
        local config=
        if [ "${chkSum}" = "${stateOrConfigChksum}" ]; then
            # This was just state
            state="${stateOrConfigChksum}"
        else
            # This was config and chksum
            config="${stateOrConfigChksum%:*}"
        fi

        # Now either config or chksum is set, and it dictates what to compare for.

        # Are we comparing state?
        if [ -n "${state}" ]; then
            # Compare state
            local setState=
            if [ ! -d "${prefix}/${pod}/release/${release}" ] || [ "${hostState}" != "active" ]; then
                # We do not have this pod release in the cluster project.
                # OR, this host is not set to "active".
                # Set state to removed on host.
                if [ "${state}" = "removed" ]; then
                    # Is already removed, so don't bother.
                    continue
                fi
                PRINT "Set pod ${pod}:${release} in removed state on host." "info" 0
                setState="removed"
            else
                # We need to make an exact comparison of states.
                # Compare states of host pod release and our local state in the cluster project.
                local localState=
                localState="$(cat "${prefix}/${pod}/release/${release}/pod.state" 2>/dev/null)"
                if [ "${localState}" != "${state}" ]; then
                    # If the states differ, then update it. Default to removed state if pod.state file was missing.
                    setState="${localState:-removed}"
                    PRINT "Change state of ${pod}:${release} from ${state} to ${setState}." "info" 0
                fi
            fi

            if [ -n "${setState}" ]; then
                # Create a statefile.
                PRINT "Create state file" "debug"
                if ! mkdir -p "${tmpDir}/pods/${pod}/release/${release}"; then
                    rm -rf "${tmpDir}"
                    PRINT "Could not write to tmp dir." "error" 0
                    return 1
                fi
                printf "%s\\n" "${setState}" >"${tmpDir}/pods/${pod}/release/${release}/pod.state"
            fi
        else
            # We are comparing config checksums
            local configDir="${prefix}/${pod}/release/${release}/config/${config}"
            local chksumFile="${prefix}/${pod}/release/${release}/config/${config}.txt"
            if [ -f "${chksumFile}" ]; then
                local chksumLocal="$(cat "${chksumFile}" 2>/dev/null)"
                if [ "${chksumLocal}" != "${chkSum}" ]; then
                    # Update config
                    PRINT "Update config ${config} for ${pod}:${release}." "info" 0
                    if ! mkdir -p "${tmpDir}/pods/${pod}/release/${release}/config"; then
                        rm -rf "${tmpDir}"
                        PRINT "Could not write to tmp dir." "error" 0
                        return 1
                    fi
                    if ! cp -r "${configDir}" "${tmpDir}/pods/${pod}/release/${release}/config"; then
                        PRINT "Could not copy config files to tmp dir." "error" 0
                        return 1
                    fi
                    if ! cp "${chksumFile}" "${tmpDir}/pods/${pod}/release/${release}/config"; then
                        PRINT "Could not copy config files to tmp dir." "error" 0
                        return 1
                    fi
                fi
            fi
        fi
    done

    ####
    # Second phase, check all pod releases in the cluster project if they do not exist on the host,
    # if not then add them and their configs to the update (unless they are in the removed state then do not add them).
    if [ -d "${prefix}" ]; then
        cd "${prefix}"
        local pod=
        for pod in $(find . -mindepth 1 -maxdepth 1 -type d -not -path './.*' |cut -b3-); do
            if [ ! -d "${pod}/release" ]; then
                continue
            fi

            cd "${pod}/release"

            local release=
            for release in $(find . -mindepth 1 -maxdepth 1 -type d -not -path './.*' |cut -b3-); do
                if ! cd "${release}" 2>/dev/null; then
                    continue
                fi

                local copy="0"
                # Get state
                local localState=
                localState="$(cat "pod.state" 2>/dev/null)"
                if [ -z "${localState}" ]; then
                    PRINT "Pod ${pod}:${release} has no pod.state file, treating it as in removed state." "warning" 0
                elif [ -n "${localState}" ] && [ "${localState}" != "removed" ]; then
                    copy="1"  # Say we want to copy it
                    # Check if this release is not present on host
                    local item=
                    for item in ${releaseData}; do
                        local pod2="${item%%:*}"
                        local release2="${item#*:}"
                        release2="${release2%%:*}"
                        local stateOrConfigChksum="${item#*:*:}"
                        if [ "${pod}" = "${pod2}" ] && [ "${release}" = "${release2}" ]; then
                            # This release is already present on host, don't add it.
                            # If there was any state change that would have been handled in the logic first phase logic.
                            copy="0"
                            break
                        fi
                    done
                fi

                cd ..  # Step out of release version

                if [ "${copy}" = "1" ]; then
                    PRINT "Copy pod ${pod}:${release} to update archive." "info" 0
                    # Copy pod release and all configs to sync
                    mkdir -p "${tmpDir}/pods/${pod}/release"
                    cp -r "${release}" "${tmpDir}/pods/${pod}/release"
                fi
            done
            cd ../.. # Step out of pod/release
        done

        cd ../../..  # Step out prefix
    fi

    # Check dir is empty
    local count="$(cd "${tmpDir}" && ls |wc -l)"

    if [ "${count}" = "0" ]; then
        # Nothing to sync
        rm -rf "${tmpDir}"
        return 2
    fi

    printf "%s\\n" "${tmpDir}"
    return 0
}

_SYNC_PERFORM_UPDATES()
{
    local _SPACE_NAME="_SYNC_PERFORM_UPDATES"

    local host="${1}"
    shift

    local tmpDir="${1}"
    shift

    # Upload archive
    local i=
    local status=
    local data=
    # Try three times before failing
    PRINT "tmpdir: ${tmpDir}" "debug"
    for i in 1 2 3; do
        data="$(cd "${tmpDir}" && tar czf - . |_REMOTE_EXEC "${host}" "upload_archive")"
        status="$?"
        if  [ "${status}" -eq 0 ] || [ "${status}" -eq 10 ]; then
            break
        fi
    done
    if [ "${status}" -ne 0 ]; then
        # Failed
        return 1
    fi

    # Unpack archive
    local i=
    local status=
    # Try three times before failing
    for i in 1 2 3; do
        _REMOTE_EXEC "${host}" "unpack_archive" "${data}"
        status="$?"
        if [ "${status}" -eq 0 ]; then
            return 0
        elif [ "${status}" -eq 10 ]; then
            return 1
        fi
    done
    return 1
}

_UTIL_CLEAR_SCREEN()
{
    local _SPACE_NAME="_UTIL_CLEAR_SCREEN"
    tput clear
}

_UTIL_GET_TMP_FILE()
{
    local _SPACE_NAME="_UTIL_GET_TMP_FILE"
    mktemp 2>/dev/null || mktemp -t 'sometmpdir'
}

FILE_APPEND_ROW()
{
    local _SPACE_NAME="FILE_APPEND_ROW"

    local data="${1}"
    shift

    local file="${1}"
    shift

    PRINT "Append row to ${file}." "debug"

    # We want to make sure that the last byte before the append, if any,
    # is a newline character.
    local newline=""
    if [ -f "${file}" ]; then
        local cr="
"
        local char=
        char="$(tail -c -1 ${file})"
        if [ "${char}" != "" ] && [ "${char}" != "${cr}" ]; then
            newline="${cr}"
        fi
    fi

    printf "%s\n" "${newline}${data}" | tee -a "${file}" >/dev/null
    if [ "$?" -gt 0 ]; then
        PRINT "Could not write to ${file}." "error"
        return 1
    fi
}

_SSH_BUILD_COMMAND()
{
    local _SPACE_NAME="_SSH_BUILD_COMMAND"

    # First check if we are provided with a hostfile, if so read it and add onto the variables.
    if [ -n "${hostfile}" ]; then
        hostfile="$(FILE_REALPATH "${hostfile}")"
        if [ ! -f "${hostfile}" ]; then
            PRINT "Given hostfile does not exist: ${hostfile}." "error"
            return 1
        fi
        if ! _SSH_BUILD_COMMAND_HOSTFILE; then
            return 1
        fi
    fi

    if [ -z "${hosts}" ]; then
        PRINT "No SSHHOST provided." "error"
        return 1
    fi

    local IFS="${IFS},"
    local count=0
    STRING_ITEM_COUNT "${hosts}" "count"
    if [ "${count}" -eq 0 ]; then
        PRINT "Missing host(s)." "error"
        return 1
    fi

    local index=0
    while [ "${index}" -lt "${count}" ]; do
        local host=
        STRING_ITEM_GET "${hosts}" ${index} "host"

        local user=
        STRING_ITEM_GET "${users}" ${index} "user"
        if [ "${user}" = "''" ]; then
            user=
        fi

        local keyfile=
        STRING_ITEM_GET "${keyfiles}" ${index} "keyfile"
        if [ "${keyfile}" = "''" ]; then
            keyfile=
        fi

        local port=22
        STRING_ITEM_GET "${ports}" ${index} "port"
        if [ "${port}" = "''" ]; then
            port=22
        fi

        local flags=
        STRING_ITEM_GET "${flagses}" ${index} "flags"
        # '' is used as placeholder for no value, it can also
        # be a prefix to actual flags that have been concatenated on,
        # so we simply remove any leading ''.
        flags="${flags#\'\'}"
        # We use semicolon as a deferred space, since a space would separate the flags.
        STRING_SUBST "flags" ';' ' ' 1

        if [ -n "${keyfile}" ]; then
            # Check permissions of key file because ssh might refuse it
            local prms=
            prms=$(FILE_STAT "${keyfile}" "%a" 2>/dev/null)
            if [ "$?" -eq 0 ]; then
                if [ "${prms%?00}" != "" ]; then
                    PRINT "The keyfile ${keyfile} has to broad permissions, ssh will likely refuse it." "warning"
                fi
            else
                PRINT "Could not stat keyfile ${keyfile}." "warning"
            fi
        fi

        if [ -z "${out_sshcommand}" ]; then
            out_sshcommand="${keyfile:+-i ${keyfile} }-p ${port} ${flags:+${flags} }${user:+${user}@}${host}"
        else
            STRING_ESCAPE "out_sshcommand" '"'
            out_sshcommand="-o proxycommand=\"ssh -W ${host}:${port} ${out_sshcommand}\" ${keyfile:+-i ${keyfile} }-p ${port} ${flags:+${flags} }${user:+${user}@}${host}"
        fi
        index=$((index+1))
    done
}

_PRJ_GET_ROUTER_HOSTS()
{
    local _SPACE_NAME="_PRJ_GET_ROUTER_HOSTS"

    local hosts=
    hosts="$(_PRJ_LIST_HOSTS 2)"

    local routerHosts=""

    local host=
    for host in ${hosts}; do
        local hostEnv="${CLUSTERPATH}/${host}/host.env"
        local varname=
        local value=
        local ROUTERADDRESS=
        for varname in ROUTERADDRESS; do
            value="$(grep -m 1 "^${varname}=" "${hostEnv}")"
            value="${value#*${varname}=}"
            STRING_TRIM "value"
            eval "${varname}=\"\${value}\""
        done
        if [ -n "${ROUTERADDRESS}" ]; then
            routerHosts="${routerHosts}${routerHosts:+;}${ROUTERADDRESS}"
        fi
    done

    printf "%s\\n" "${routerHosts}"
}

FILE_STAT()
{
    local _SPACE_NAME="FILE_STAT"

    local file="${1}"
    shift

    local format="${1}"
    shift

    #
    # Check for BSD stat
    if command -v "pkg" >/dev/null || command -v "brew" >/dev/null ; then
        # Translate format options
        format=$(printf "%s" "${format}" | sed -e s'/%a/%A/g' -e s'/%n/%N/g' -e s'/%U/%Su/g' -e s'/%G/%Sg/g' -e s'/%Y/%m/g')
        stat -f "${format}" "${file}"
    else
        stat -c "${format}" "${file}"
    fi

    if [ "$?" -gt 0 ]; then
        PRINT "Failed to stat file: ${file}." "error"
        return 1
    fi
}

_SSH_BUILD_COMMAND_HOSTFILE()
{
    local _SPACE_NAME="_SSH_BUILD_COMMAND_HOSTFILE"

    local HOST=
    local USER=
    local KEYFILE=
    local PORT=
    local FLAGS=
    local JUMPHOST=
    local counter="0"
    while true; do
        counter="$((counter+1))"

        if [ "${counter}" -gt 10 ]; then
            PRINT "Jumphost count exceeded, maximum 10 allowed." "error"
            return 1
        fi

        local value=
        local varname=
        for varname in HOST USER KEYFILE PORT FLAGS JUMPHOST; do
            value="$(grep -m 1 "^${varname}=" "${hostfile}")"
            value="${value#*${varname}=}"
            eval "${varname}=\"\${value}\""
        done

        if [ "$(STRING_SUBSTR "${KEYFILE}" 0 1)" != '/' ]; then
            KEYFILE="${HOME}/${KEYFILE}"
        fi
        if [ "$(STRING_SUBSTR "${JUMPHOST}" 0 1)" != '/' ]; then
            JUMPHOST="${HOME}/${JUMPHOST}"
        fi

        STRING_SUBST "FLAGS" ' ' ';' 1

        if [ -n "${KEYFILE}" ]; then
            KEYFILE="$(cd "${hostfile%/*}/" && FILE_REALPATH "${KEYFILE}")"
        fi

        if [ -z "${HOST}" ]; then
            PRINT "HOST must be defined in ${hostfile}." "error"
            return 1
        fi

        USER="${USER:-''}"
        KEYFILE="${KEYFILE:-''}"
        PORT="${PORT:-22}"
        FLAGS="${FLAGS:-''}"
        hosts="${HOST}${hosts:+ }${hosts}"
        users="${USER}${users:+ }${users}"
        keyfiles="${KEYFILE}${keyfiles:+ }${keyfiles}"
        ports="${PORT}${ports:+ }${ports}"
        flagses="${FLAGS}${flagses:+ }${flagses}"

        if [ -n "${JUMPHOST}" ]; then
            hostfile="${hostfile%/*}/${JUMPHOST}"
            if [ ! -f "${hostfile}" ]; then
                hostfile="${hostfile}/host.env"
            fi
            hostfile="$(FILE_REALPATH "${hostfile}")"
            if [ ! -f "${hostfile}" ]; then
                PRINT "JUMPHOST ${JUMPHOST} env file does not exist as: ${hostfile}" "error"
                return 1
            fi
            # Iterate again using JUMPHOST
        else
            break
        fi
    done
}

main()
{
    SNT_CMDLINE "$@"

    # Space will print exit status.
    local _status=$?
    if [ "${_status}" -ne "${SPACE_ASSERT_EXIT}" ]; then
        if [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 1 ]; then
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[31m" >&2
            printf "%s\n" "[ERROR] Script exited with status $_status for node /cmdline/" >&2
            [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ -t 2 ] && printf "\033[0m" >&2
        fi
        if [ "${SPACE_MUTE_EXIT}" != 1 ]; then
            return $((SPACE_ASSERT_EXIT == 0 ? _status : 1))
        fi
    elif [ "${SPACE_MUTE_EXIT_MESSAGE}" != "1" ] && [ "${SPACE_LOG_LEVEL}" -ge 5 ]; then
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[32m" >&2
        printf "%s\n" "[DEBUG] Script exited with success (status $_status) for node /cmdline/" >&2
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = "1" ] && [ 5 -eq 3 ] && [ -t 2 ] && printf "\033[0m" >&2
        : # Important to reset status here.
    fi
}

main "$@"
